{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Ben's Code Journal May it aid you in your coding adventures if a google search lands you here.","title":"Home"},{"location":"#welcome-to-bens-code-journal","text":"May it aid you in your coding adventures if a google search lands you here.","title":"Welcome to Ben's Code Journal"},{"location":"Quick Notes/","text":"Quick Notes Deploy the server\\site Be sure you are in ./code-journal/ or ./<project root> code-journal |-docs |-site |-mkdocs.yml Benjamins-MBP-2:code-journal bbearce$ pwd /Users/bbearce/Documents/Code/code-journal Use this code to serve the developer site $ mkdocs serve Use this code to build the site $ mkdocs build To push to github do this: cd ../bbearce.github.io/ mkdocs gh-deploy --config-file ../code-journal/mkdocs.yml --remote-branch master Detailed Github Notes github deploy","title":"MKDocs"},{"location":"Quick Notes/#quick-notes","text":"","title":"Quick Notes"},{"location":"Quick Notes/#deploy-the-serversite","text":"Be sure you are in ./code-journal/ or ./<project root> code-journal |-docs |-site |-mkdocs.yml Benjamins-MBP-2:code-journal bbearce$ pwd /Users/bbearce/Documents/Code/code-journal Use this code to serve the developer site $ mkdocs serve Use this code to build the site $ mkdocs build To push to github do this: cd ../bbearce.github.io/ mkdocs gh-deploy --config-file ../code-journal/mkdocs.yml --remote-branch master","title":"Deploy the server\\site"},{"location":"Quick Notes/#detailed-github-notes","text":"github deploy","title":"Detailed Github Notes"},{"location":"bash/tar_files/","text":"Tar Files When downloading 3DSlicer you get a *.tar file. This command installs it. tar zxvf Slicer-4.8.1-linux-amd64.tar.gz FYI: ( Link ) z means (un)z\u0332ip. x means ex\u0332tract files from the archive. v means print the filenames v\u0332erbosely. f means the following argument is a f\u0331ilename. ...https://askubuntu.com/questions/25961/how-do-i-install-a-tar-gz-or-tar-bz2-file","title":"Bash"},{"location":"bash/tar_files/#tar-files","text":"When downloading 3DSlicer you get a *.tar file. This command installs it. tar zxvf Slicer-4.8.1-linux-amd64.tar.gz FYI: ( Link ) z means (un)z\u0332ip. x means ex\u0332tract files from the archive. v means print the filenames v\u0332erbosely. f means the following argument is a f\u0331ilename. ...https://askubuntu.com/questions/25961/how-do-i-install-a-tar-gz-or-tar-bz2-file","title":"Tar Files"},{"location":"javascript/Javascript/","text":"Javascript console.log('strings!!!')","title":"Javascript"},{"location":"javascript/Javascript/#javascript","text":"console.log('strings!!!')","title":"Javascript"},{"location":"python/Installs/","text":"Installs Installing You an use wget to grab the latest like so: cd /usr/src sudo wget https://www.python.org/ftp/python/3.7.4/Python-3.7.4.tgz You can also go to https://www.python.org/ and download it. This gave me a Python-3.7.4.tar.xz file. To unzip it use: $ tar -xf Python-3.7.4.tar.xz $ ls -la drwxr-xr-x 18 bbearce bbearce 4096 Jul 8 14:31 Python-3.7.4 -rw-rw-r-- 1 bbearce bbearce 17131432 Sep 4 11:09 Python-3.7.4.tar.xz To see other unzipping techniques for different file types try here Change into that new directory and use make to install Python: $ cd Python-3.7.4 Note: Notice the README.rst $ vi README.rst ... Build Instructions On Unix, Linux, BSD, macOS, and Cygwin:: ./configure make make test sudo make install This will install Python as python3 . ... Installing multiple versions On Unix and Mac systems if you intend to install multiple versions of Python using the same installation prefix ( --prefix argument to the configure script) you must take care that your primary python executable is not overwritten by the installation of a different version. All files and directories installed using make altinstall contain the major and minor version and can thus live side-by-side. make install also creates ${prefix}/bin/python3 which refers to ${prefix}/bin/pythonX.Y . If you intend to install multiple versions using the same prefix you must decide which version (if any) is your \"primary\" version. Install that version using make install . Install all other versions using make altinstall . To continue run make : $ ./configure $ make $ make test $ sudo make altinstall","title":"Installs"},{"location":"python/Installs/#installs","text":"","title":"Installs"},{"location":"python/Installs/#installing","text":"You an use wget to grab the latest like so: cd /usr/src sudo wget https://www.python.org/ftp/python/3.7.4/Python-3.7.4.tgz You can also go to https://www.python.org/ and download it. This gave me a Python-3.7.4.tar.xz file. To unzip it use: $ tar -xf Python-3.7.4.tar.xz $ ls -la drwxr-xr-x 18 bbearce bbearce 4096 Jul 8 14:31 Python-3.7.4 -rw-rw-r-- 1 bbearce bbearce 17131432 Sep 4 11:09 Python-3.7.4.tar.xz To see other unzipping techniques for different file types try here Change into that new directory and use make to install Python: $ cd Python-3.7.4 Note: Notice the README.rst $ vi README.rst ...","title":"Installing"},{"location":"python/Installs/#build-instructions","text":"On Unix, Linux, BSD, macOS, and Cygwin:: ./configure make make test sudo make install This will install Python as python3 . ...","title":"Build Instructions"},{"location":"python/Installs/#installing-multiple-versions","text":"On Unix and Mac systems if you intend to install multiple versions of Python using the same installation prefix ( --prefix argument to the configure script) you must take care that your primary python executable is not overwritten by the installation of a different version. All files and directories installed using make altinstall contain the major and minor version and can thus live side-by-side. make install also creates ${prefix}/bin/python3 which refers to ${prefix}/bin/pythonX.Y . If you intend to install multiple versions using the same prefix you must decide which version (if any) is your \"primary\" version. Install that version using make install . Install all other versions using make altinstall . To continue run make : $ ./configure $ make $ make test $ sudo make altinstall","title":"Installing multiple versions"},{"location":"python/advanced/Classes/","text":"Classes Basic Class Definition Intro: - Class: Blueprint - Object - Instance class Shark: # Basic Method definition def swim(self): print(\"The shark is swimming.\") def be_awesome(self): print(\"The shark is being awesome.\") Notice the use of self to reference an instance specifically...the one calling the method. Implementing sammy = Shark() sammy.swim() # >>> The shark is swimming. sammy.be_awesome() # >>> The shark is being awesome. Now let's dicuss init . class Shark: def __init__(self): print(\"This is the constructor method.\") >>> Shark() This is the constructor method. <__main__.Shark object at 0x10348d470> Finally, we can set the name of the Shark object sammy as equal to \"Sammy\" by passing it as a parameter of the Shark class: class Shark: def __init__(self, name): self.name = name def swim(self): print(self.name + \" is swimming.\") def be_awesome(self): print(self.name + \" is being awesome.\") def main(): # Set name of Shark object sammy = Shark(\"Sammy\") sammy.swim() sammy.be_awesome() if __name__ == \"__main__\": main() run... $ python shark.py Sammy is swimming. Sammy is being awesome. Inheritance super() and inheritance. In this tutorial, you\u2019ll learn about the following: The concept of inheritance in Python Multiple inheritance in Python How the super() function works How the super() function in single inheritance works How the super() function in multiple inheritance works Let's start with a simple example: class Rectangle: def __init__(self, length, width): self.length = length self.width = width def area(self): return self.length * self.width def perimeter(self): return 2 * self.length + 2 * self.width class Square: def __init__(self, length): self.length = length def area(self): return self.length * self.length def perimeter(self): return 4 * self.length >>> square = Square(4) >>> square.area() 16 >>> rectangle = Rectangle(2,4) >>> rectangle.area() 8 Here no references to inheritance are being made. super() in Single Inheritance super() gives you access to methods in a superclass from the subclass that inherits from it. super() alone returns a temporary object of the superclass that then allows you to call that superclass\u2019s methods. By using inheritance, you can reduce the amount of code you write while simultaneously reflecting the real-world relationship between rectangles and squares: class Rectangle: def __init__(self, length, width): self.length = length self.width = width def area(self): return self.length * self.width def perimeter(self): return 2 * self.length + 2 * self.width # Here we declare that the Square class inherits from the Rectangle class class Square(Rectangle): def __init__(self, length): super().__init__(length, length) >>> square = Square(4) >>> square.area() 16 What Can super() Do for You? Like in other object-oriented languages, it allows you to call methods of the superclass in your subclass. The primary use case of this is to extend the functionality of the inherited method. In the example below, you will create a class Cube that inherits from Square and extends the functionality of .area() (inherited from the Rectangle class through Square) to calculate the surface area and volume of a Cube instance: class Square(Rectangle): def __init__(self, length): super().__init__(length, length) class Cube(Square): def surface_area(self): face_area = super().area() return face_area * 6 def volume(self): face_area = super().area() return face_area * self.length >>> cube = Cube(3) >>> cube.surface_area() 54 >>> cube.volume() 27 Here you have implemented two methods for the Cube class: .surface_area() and .volume(). Both of these calculations rely on calculating the area of a single face, so rather than reimplementing the area calculation, you use super() to extend the area calculation. Also notice that the Cube class definition does not have an . init (). Because Cube inherits from Square and . init () doesn\u2019t really do anything differently for Cube than it already does for Square, you can skip defining it, and the . init () of the superclass (Square) will be called automatically. A super() Deep Dive While the examples above (and below) call super() without any parameters, super() can also take two parameters: the first is the subclass, and the second parameter is an object that is an instance of that subclass. First, let\u2019s see two examples showing what manipulating the first variable can do, using the classes already shown: class Rectangle: def __init__(self, length, width): self.length = length self.width = width def area(self): return self.length * self.width def perimeter(self): return 2 * self.length + 2 * self.width class Square(Rectangle): def __init__(self, length): super(Square, self).__init__(length, length) In Python 3, the super(Square, self) call is equivalent to the parameterless super() call. The first parameter refers to the subclass Square, while the second parameter refers to a Square object which, in this case, is self. You can call super() with other classes as well: class Cube(Square): def surface_area(self): face_area = super(Square, self).area() return face_area * 6 def volume(self): face_area = super(Square, self).area() return face_area * self.length In this example, you are setting Square as the subclass argument to super(), instead of Cube. This causes super() to start searching for a matching method (in this case, .area()) at one level above Square in the instance hierarchy, in this case Rectangle. In this specific example, the behavior doesn\u2019t change. But imagine that Square also implemented an .area() function that you wanted to make sure Cube did not use. Calling super() in this way allows you to do that. What about the second parameter? Remember, this is an object that is an instance of the class used as the first parameter. For an example, isinstance(Cube, Square) must return True. By including an instantiated object, super() returns a bound method: a method that is bound to the object, which gives the method the object\u2019s context such as any instance attributes. If this parameter is not included, the method returned is just a function, unassociated with an object\u2019s context. For more information about bound methods, unbound methods, and functions, read the Python documentation on its descriptor system . Multiple Inheritance and Composition super() in Multiple Inheritance Now that you\u2019ve worked through an overview and some examples of super() and single inheritance, you will be introduced to an overview and some examples that will demonstrate how multiple inheritance works and how super() enables that functionality. Multiple Inheritance Overview There is another use case in which super() really shines, and this one isn\u2019t as common as the single inheritance scenario. In addition to single inheritance, Python supports multiple inheritance, in which a subclass can inherit from multiple superclasses that don\u2019t necessarily inherit from each other (also known as sibling classes). Superclass 1 Superclass 2 | | | | | | | | | | ------> Subclass <------- Let's get reacquainted with our base code: class Rectangle: def __init__(self, length, width): self.length = length self.width = width def area(self): return self.length * self.width def perimeter(self): return 2 * self.length + 2 * self.width class Square(Rectangle): def __init__(self, length): super(Square, self).__init__(length, length) Now let's proceed... To better illustrate multiple inheritance in action, here is some code for you to try out, showing how you can build a right pyramid (a pyramid with a square base) out of a Triangle and a Square: class Triangle: def __init__(self, base, height): self.base = base self.height = height def area(self): return 0.5 * self.base * self.height class RightPyramid(Triangle, Square): def __init__(self, base, slant_height): self.base = base self.slant_height = slant_height def area(self): base_area = super().area() perimeter = super().perimeter() return 0.5 * perimeter * self.slant_height + base_area This example declares a Triangle class and a RightPyramid class that inherits from both Square and Triangle. You\u2019ll see another .area() method that uses super() just like in single inheritance, with the aim of it reaching the .perimeter() and .area() methods defined all the way up in the Rectangle class. The problem, though, is that both superclasses (Triangle and Square) define a .area(). Take a second and think about what might happen when you call .area() on RightPyramid, and then try calling it like below: >> pyramid = RightPyramid(2, 4) >> pyramid.area() Traceback (most recent call last): File \"shapes.py\", line 63, in print(pyramid.area()) File \"shapes.py\", line 47, in area base_area = super().area() File \"shapes.py\", line 38, in area return 0.5 * self.base * self.height AttributeError: 'RightPyramid' object has no attribute 'height' Did you guess that Python will try to call Triangle.area()? This is because of something called the method resolution order. Method Resolution Order The method resolution order (or MRO) tells Python how to search for inherited methods. This comes in handy when you\u2019re using super() because the MRO tells you exactly where Python will look for a method you\u2019re calling with super() and in what order. Every class has an . mro attribute that allows us to inspect the order, so let\u2019s do that: >>> RightPyramid.__mro__ (<class '__main__.RightPyramid'>, <class '__main__.Triangle'>, <class '__main__.Square'>, <class '__main__.Rectangle'>, <class 'object'>) This tells us that methods will be searched first in Rightpyramid, then in Triangle, then in Square, then Rectangle, and then, if nothing is found, in object, from which all classes originate. The problem here is that the interpreter is searching for .area() in Triangle before Square and Rectangle, and upon finding .area() in Triangle, Python calls it instead of the one you want. Because Triangle.area() expects there to be a .height and a .base attribute, Python throws an AttributeError. The problem here is that the interpreter is searching for .area() in Triangle before Square and Rectangle, and upon finding .area() in Triangle, Python calls it instead of the one you want. Because Triangle.area() expects there to be a .height and a .base attribute, Python throws an AttributeError. Luckily, you have some control over how the MRO is constructed. Just by changing the signature of the RightPyramid class, you can search in the order you want, and the methods will resolve correctly: class RightPyramid(Square, Triangle): def __init__(self, base, slant_height): self.base = base self.slant_height = slant_height super().__init__(self.base) def area(self): base_area = super().area() perimeter = super().perimeter() return 0.5 * perimeter * self.slant_height + base_area Notice that RightPyramid initializes partially with the . init () from the Square class. This allows .area() to use the .length on the object, as is designed. Now, you can build a pyramid, inspect the MRO, and calculate the surface area: >>> pyramid = RightPyramid(2, 4) >>> RightPyramid.__mro__ (<class '__main__.RightPyramid'>, <class '__main__.Square'>, <class '__main__.Rectangle'>, <class '__main__.Triangle'>, <class 'object'>) >>> pyramid.area() 20.0 You see that the MRO is now what you\u2019d expect, and you can inspect the area of the pyramid as well, thanks to .area() and .perimeter(). There\u2019s still a problem here, though. For the sake of simplicity, I did a few things wrong in this example: the first, and arguably most importantly, was that I had two separate classes with the same method name and signature. This causes issues with method resolution, because the first instance of .area() that is encountered in the MRO list will be called. When you\u2019re using super() with multiple inheritance, it\u2019s imperative to design your classes to cooperate. Part of this is ensuring that your methods are unique so that they get resolved in the MRO, by making sure method signatures are unique\u2014whether by using method names or method parameters. In this case, to avoid a complete overhaul of your code, you can rename the Triangle class\u2019s .area() method to .tri_area(). This way, the area methods can continue using class properties rather than taking external parameters: class Triangle: def __init__(self, base, height): self.base = base self.height = height super().__init__() def tri_area(self): return 0.5 * self.base * self.height Let\u2019s also go ahead and use this in the RightPyramid class: class RightPyramid(Square, Triangle): def __init__(self, base, slant_height): self.base = base self.slant_height = slant_height super().__init__(self.base) def area(self): base_area = super().area() perimeter = super().perimeter() return 0.5 * perimeter * self.slant_height + base_area def area_2(self): base_area = super().area() triangle_area = super().tri_area() return triangle_area * 4 + base_area The next issue here is that the code doesn\u2019t have a delegated Triangle object like it does for a Square object, so calling .area_2() will give us an AttributeError since .base and .height don\u2019t have any values. You need to do two things to fix this: All methods that are called with super() need to have a call to their superclass\u2019s version of that method. This means that you will need to add super(). init () to the . init () methods of Triangle and Rectangle. Redesign all the . init () calls to take a keyword dictionary. See the complete code below. class Rectangle: def __init__(self, length, width, **kwargs): self.length = length self.width = width super().__init__(**kwargs) def area(self): return self.length * self.width def perimeter(self): return 2 * self.length + 2 * self.width # Here we declare that the Square class inherits from # the Rectangle class class Square(Rectangle): def __init__(self, length, **kwargs): super().__init__(length=length, width=length, **kwargs) class Cube(Square): def surface_area(self): face_area = super().area() return face_area * 6 def volume(self): face_area = super().area() return face_area * self.length class Triangle: def __init__(self, base, height, **kwargs): self.base = base self.height = height super().__init__(**kwargs) def tri_area(self): return 0.5 * self.base * self.height class RightPyramid(Square, Triangle): def __init__(self, base, slant_height, **kwargs): self.base = base self.slant_height = slant_height kwargs[\"height\"] = slant_height kwargs[\"length\"] = base super().__init__(base=base, **kwargs) def area(self): base_area = super().area() perimeter = super().perimeter() return 0.5 * perimeter * self.slant_height + base_area def area_2(self): base_area = super().area() triangle_area = super().tri_area() return triangle_area * 4 + base_area There are a number of important differences in this code: kwargs is modified in some places (such as RightPyramid. init ()): This will allow users of these objects to instantiate them only with the arguments that make sense for that particular object. Setting up named arguments before kwargs: You can see this in RightPyramid. init (). This has the neat effect of popping that key right out of the kwargs dictionary, so that by the time that it ends up at the end of the MRO in the object class, **kwargs is empty. Now, when you use these updated classes, you have this: >>> pyramid = RightPyramid(base=2, slant_height=4) >>> pyramid.area() 20.0 >>> pyramid.area_2() 20.0 It works! You\u2019ve used super() to successfully navigate a complicated class hierarchy while using both inheritance and composition to create new classes with minimal reimplementation. Quiz!!! When Rectangle calls super() what are the values of kwargs and what class gets it's init method called Answer: kwargs is still containing {'base': 2, 'height': 4} values as they haven't been removed from kwargs super().__init__(**kwargs) calls Triangle's init , but Rectangle doesn't inherit from Triangle so why? Remember the MRO? Let's look at RightPyramid's MRO >>> RightPyramid.__mro__ (<class '__main__.RightPyramid'>, <class '__main__.Square'>, <class '__main__.Rectangle'>, <class '__main__.Triangle'>, <class 'object'>) Even though Rectangle doesn't inherit from Triangle, Triangle is next in the list of classes to search for an init method. You'll notice object is at the end of the list. super().__init__(**kwargs) Multiple Inheritance Alternatives As you can see, multiple inheritance can be useful but also lead to very complicated situations and code that is hard to read. It\u2019s also rare to have objects that neatly inherit everything from more than multiple other objects. If you see yourself beginning to use multiple inheritance and a complicated class hierarchy, it\u2019s worth asking yourself if you can achieve code that is cleaner and easier to understand by using composition instead of inheritance. With composition, you can add very specific functionality to your classes from a specialized, simple class called a mixin. Since this article is focused on inheritance, I won\u2019t go into too much detail on composition and how to wield it in Python, but here\u2019s a short example using VolumeMixin to give specific functionality to our 3D objects\u2014in this case, a volume calculation: class Rectangle: def __init__(self, length, width): self.length = length self.width = width def area(self): return self.length * self.width class Square(Rectangle): def __init__(self, length): super().__init__(length, length) class VolumeMixin: def volume(self): return self.area() * self.height class Cube(VolumeMixin, Square): def __init__(self, length): super().__init__(length) self.height = length def face_area(self): return super().area() def surface_area(self): return super().area() * 6 In this example, the code was reworked to include a mixin called VolumeMixin. The mixin is then used by Cube and gives Cube the ability to calculate its volume, which is shown below: >>> cube = Cube(2) >>> cube.surface_area() 24 >>> cube.volume() 8 A super() Recap In this tutorial, you learned how to supercharge your classes with super(). Your journey started with a review of single inheritance and then showed how to call superclass methods easily with super(). You then learned how multiple inheritance works in Python, and techniques to combine super() with multiple inheritance. You also learned about how Python resolves method calls using the method resolution order (MRO), as well as how to inspect and modify the MRO to ensure appropriate methods are called at appropriate times. For more information about object-oriented programming in Python and using super(), check out these resources: Official super() documentation Python\u2019s super() Considered Super by Raymond Hettinger Object-Oriented Programming in Python 3","title":"Classes"},{"location":"python/advanced/Classes/#classes","text":"","title":"Classes"},{"location":"python/advanced/Classes/#basic-class-definition","text":"Intro: - Class: Blueprint - Object - Instance class Shark: # Basic Method definition def swim(self): print(\"The shark is swimming.\") def be_awesome(self): print(\"The shark is being awesome.\") Notice the use of self to reference an instance specifically...the one calling the method. Implementing sammy = Shark() sammy.swim() # >>> The shark is swimming. sammy.be_awesome() # >>> The shark is being awesome. Now let's dicuss init . class Shark: def __init__(self): print(\"This is the constructor method.\") >>> Shark() This is the constructor method. <__main__.Shark object at 0x10348d470> Finally, we can set the name of the Shark object sammy as equal to \"Sammy\" by passing it as a parameter of the Shark class: class Shark: def __init__(self, name): self.name = name def swim(self): print(self.name + \" is swimming.\") def be_awesome(self): print(self.name + \" is being awesome.\") def main(): # Set name of Shark object sammy = Shark(\"Sammy\") sammy.swim() sammy.be_awesome() if __name__ == \"__main__\": main() run... $ python shark.py Sammy is swimming. Sammy is being awesome.","title":"Basic Class Definition"},{"location":"python/advanced/Classes/#inheritance","text":"super() and inheritance. In this tutorial, you\u2019ll learn about the following: The concept of inheritance in Python Multiple inheritance in Python How the super() function works How the super() function in single inheritance works How the super() function in multiple inheritance works Let's start with a simple example: class Rectangle: def __init__(self, length, width): self.length = length self.width = width def area(self): return self.length * self.width def perimeter(self): return 2 * self.length + 2 * self.width class Square: def __init__(self, length): self.length = length def area(self): return self.length * self.length def perimeter(self): return 4 * self.length >>> square = Square(4) >>> square.area() 16 >>> rectangle = Rectangle(2,4) >>> rectangle.area() 8 Here no references to inheritance are being made. super() in Single Inheritance super() gives you access to methods in a superclass from the subclass that inherits from it. super() alone returns a temporary object of the superclass that then allows you to call that superclass\u2019s methods. By using inheritance, you can reduce the amount of code you write while simultaneously reflecting the real-world relationship between rectangles and squares: class Rectangle: def __init__(self, length, width): self.length = length self.width = width def area(self): return self.length * self.width def perimeter(self): return 2 * self.length + 2 * self.width # Here we declare that the Square class inherits from the Rectangle class class Square(Rectangle): def __init__(self, length): super().__init__(length, length) >>> square = Square(4) >>> square.area() 16 What Can super() Do for You? Like in other object-oriented languages, it allows you to call methods of the superclass in your subclass. The primary use case of this is to extend the functionality of the inherited method. In the example below, you will create a class Cube that inherits from Square and extends the functionality of .area() (inherited from the Rectangle class through Square) to calculate the surface area and volume of a Cube instance: class Square(Rectangle): def __init__(self, length): super().__init__(length, length) class Cube(Square): def surface_area(self): face_area = super().area() return face_area * 6 def volume(self): face_area = super().area() return face_area * self.length >>> cube = Cube(3) >>> cube.surface_area() 54 >>> cube.volume() 27 Here you have implemented two methods for the Cube class: .surface_area() and .volume(). Both of these calculations rely on calculating the area of a single face, so rather than reimplementing the area calculation, you use super() to extend the area calculation. Also notice that the Cube class definition does not have an . init (). Because Cube inherits from Square and . init () doesn\u2019t really do anything differently for Cube than it already does for Square, you can skip defining it, and the . init () of the superclass (Square) will be called automatically. A super() Deep Dive While the examples above (and below) call super() without any parameters, super() can also take two parameters: the first is the subclass, and the second parameter is an object that is an instance of that subclass. First, let\u2019s see two examples showing what manipulating the first variable can do, using the classes already shown: class Rectangle: def __init__(self, length, width): self.length = length self.width = width def area(self): return self.length * self.width def perimeter(self): return 2 * self.length + 2 * self.width class Square(Rectangle): def __init__(self, length): super(Square, self).__init__(length, length) In Python 3, the super(Square, self) call is equivalent to the parameterless super() call. The first parameter refers to the subclass Square, while the second parameter refers to a Square object which, in this case, is self. You can call super() with other classes as well: class Cube(Square): def surface_area(self): face_area = super(Square, self).area() return face_area * 6 def volume(self): face_area = super(Square, self).area() return face_area * self.length In this example, you are setting Square as the subclass argument to super(), instead of Cube. This causes super() to start searching for a matching method (in this case, .area()) at one level above Square in the instance hierarchy, in this case Rectangle. In this specific example, the behavior doesn\u2019t change. But imagine that Square also implemented an .area() function that you wanted to make sure Cube did not use. Calling super() in this way allows you to do that. What about the second parameter? Remember, this is an object that is an instance of the class used as the first parameter. For an example, isinstance(Cube, Square) must return True. By including an instantiated object, super() returns a bound method: a method that is bound to the object, which gives the method the object\u2019s context such as any instance attributes. If this parameter is not included, the method returned is just a function, unassociated with an object\u2019s context. For more information about bound methods, unbound methods, and functions, read the Python documentation on its descriptor system .","title":"Inheritance"},{"location":"python/advanced/Classes/#multiple-inheritance-and-composition","text":"super() in Multiple Inheritance Now that you\u2019ve worked through an overview and some examples of super() and single inheritance, you will be introduced to an overview and some examples that will demonstrate how multiple inheritance works and how super() enables that functionality. Multiple Inheritance Overview There is another use case in which super() really shines, and this one isn\u2019t as common as the single inheritance scenario. In addition to single inheritance, Python supports multiple inheritance, in which a subclass can inherit from multiple superclasses that don\u2019t necessarily inherit from each other (also known as sibling classes). Superclass 1 Superclass 2 | | | | | | | | | | ------> Subclass <------- Let's get reacquainted with our base code: class Rectangle: def __init__(self, length, width): self.length = length self.width = width def area(self): return self.length * self.width def perimeter(self): return 2 * self.length + 2 * self.width class Square(Rectangle): def __init__(self, length): super(Square, self).__init__(length, length) Now let's proceed... To better illustrate multiple inheritance in action, here is some code for you to try out, showing how you can build a right pyramid (a pyramid with a square base) out of a Triangle and a Square: class Triangle: def __init__(self, base, height): self.base = base self.height = height def area(self): return 0.5 * self.base * self.height class RightPyramid(Triangle, Square): def __init__(self, base, slant_height): self.base = base self.slant_height = slant_height def area(self): base_area = super().area() perimeter = super().perimeter() return 0.5 * perimeter * self.slant_height + base_area This example declares a Triangle class and a RightPyramid class that inherits from both Square and Triangle. You\u2019ll see another .area() method that uses super() just like in single inheritance, with the aim of it reaching the .perimeter() and .area() methods defined all the way up in the Rectangle class. The problem, though, is that both superclasses (Triangle and Square) define a .area(). Take a second and think about what might happen when you call .area() on RightPyramid, and then try calling it like below: >> pyramid = RightPyramid(2, 4) >> pyramid.area() Traceback (most recent call last): File \"shapes.py\", line 63, in print(pyramid.area()) File \"shapes.py\", line 47, in area base_area = super().area() File \"shapes.py\", line 38, in area return 0.5 * self.base * self.height AttributeError: 'RightPyramid' object has no attribute 'height' Did you guess that Python will try to call Triangle.area()? This is because of something called the method resolution order. Method Resolution Order The method resolution order (or MRO) tells Python how to search for inherited methods. This comes in handy when you\u2019re using super() because the MRO tells you exactly where Python will look for a method you\u2019re calling with super() and in what order. Every class has an . mro attribute that allows us to inspect the order, so let\u2019s do that: >>> RightPyramid.__mro__ (<class '__main__.RightPyramid'>, <class '__main__.Triangle'>, <class '__main__.Square'>, <class '__main__.Rectangle'>, <class 'object'>) This tells us that methods will be searched first in Rightpyramid, then in Triangle, then in Square, then Rectangle, and then, if nothing is found, in object, from which all classes originate. The problem here is that the interpreter is searching for .area() in Triangle before Square and Rectangle, and upon finding .area() in Triangle, Python calls it instead of the one you want. Because Triangle.area() expects there to be a .height and a .base attribute, Python throws an AttributeError. The problem here is that the interpreter is searching for .area() in Triangle before Square and Rectangle, and upon finding .area() in Triangle, Python calls it instead of the one you want. Because Triangle.area() expects there to be a .height and a .base attribute, Python throws an AttributeError. Luckily, you have some control over how the MRO is constructed. Just by changing the signature of the RightPyramid class, you can search in the order you want, and the methods will resolve correctly: class RightPyramid(Square, Triangle): def __init__(self, base, slant_height): self.base = base self.slant_height = slant_height super().__init__(self.base) def area(self): base_area = super().area() perimeter = super().perimeter() return 0.5 * perimeter * self.slant_height + base_area Notice that RightPyramid initializes partially with the . init () from the Square class. This allows .area() to use the .length on the object, as is designed. Now, you can build a pyramid, inspect the MRO, and calculate the surface area: >>> pyramid = RightPyramid(2, 4) >>> RightPyramid.__mro__ (<class '__main__.RightPyramid'>, <class '__main__.Square'>, <class '__main__.Rectangle'>, <class '__main__.Triangle'>, <class 'object'>) >>> pyramid.area() 20.0 You see that the MRO is now what you\u2019d expect, and you can inspect the area of the pyramid as well, thanks to .area() and .perimeter(). There\u2019s still a problem here, though. For the sake of simplicity, I did a few things wrong in this example: the first, and arguably most importantly, was that I had two separate classes with the same method name and signature. This causes issues with method resolution, because the first instance of .area() that is encountered in the MRO list will be called. When you\u2019re using super() with multiple inheritance, it\u2019s imperative to design your classes to cooperate. Part of this is ensuring that your methods are unique so that they get resolved in the MRO, by making sure method signatures are unique\u2014whether by using method names or method parameters. In this case, to avoid a complete overhaul of your code, you can rename the Triangle class\u2019s .area() method to .tri_area(). This way, the area methods can continue using class properties rather than taking external parameters: class Triangle: def __init__(self, base, height): self.base = base self.height = height super().__init__() def tri_area(self): return 0.5 * self.base * self.height Let\u2019s also go ahead and use this in the RightPyramid class: class RightPyramid(Square, Triangle): def __init__(self, base, slant_height): self.base = base self.slant_height = slant_height super().__init__(self.base) def area(self): base_area = super().area() perimeter = super().perimeter() return 0.5 * perimeter * self.slant_height + base_area def area_2(self): base_area = super().area() triangle_area = super().tri_area() return triangle_area * 4 + base_area The next issue here is that the code doesn\u2019t have a delegated Triangle object like it does for a Square object, so calling .area_2() will give us an AttributeError since .base and .height don\u2019t have any values. You need to do two things to fix this: All methods that are called with super() need to have a call to their superclass\u2019s version of that method. This means that you will need to add super(). init () to the . init () methods of Triangle and Rectangle. Redesign all the . init () calls to take a keyword dictionary. See the complete code below. class Rectangle: def __init__(self, length, width, **kwargs): self.length = length self.width = width super().__init__(**kwargs) def area(self): return self.length * self.width def perimeter(self): return 2 * self.length + 2 * self.width # Here we declare that the Square class inherits from # the Rectangle class class Square(Rectangle): def __init__(self, length, **kwargs): super().__init__(length=length, width=length, **kwargs) class Cube(Square): def surface_area(self): face_area = super().area() return face_area * 6 def volume(self): face_area = super().area() return face_area * self.length class Triangle: def __init__(self, base, height, **kwargs): self.base = base self.height = height super().__init__(**kwargs) def tri_area(self): return 0.5 * self.base * self.height class RightPyramid(Square, Triangle): def __init__(self, base, slant_height, **kwargs): self.base = base self.slant_height = slant_height kwargs[\"height\"] = slant_height kwargs[\"length\"] = base super().__init__(base=base, **kwargs) def area(self): base_area = super().area() perimeter = super().perimeter() return 0.5 * perimeter * self.slant_height + base_area def area_2(self): base_area = super().area() triangle_area = super().tri_area() return triangle_area * 4 + base_area There are a number of important differences in this code: kwargs is modified in some places (such as RightPyramid. init ()): This will allow users of these objects to instantiate them only with the arguments that make sense for that particular object. Setting up named arguments before kwargs: You can see this in RightPyramid. init (). This has the neat effect of popping that key right out of the kwargs dictionary, so that by the time that it ends up at the end of the MRO in the object class, **kwargs is empty. Now, when you use these updated classes, you have this: >>> pyramid = RightPyramid(base=2, slant_height=4) >>> pyramid.area() 20.0 >>> pyramid.area_2() 20.0 It works! You\u2019ve used super() to successfully navigate a complicated class hierarchy while using both inheritance and composition to create new classes with minimal reimplementation. Quiz!!! When Rectangle calls super() what are the values of kwargs and what class gets it's init method called Answer: kwargs is still containing {'base': 2, 'height': 4} values as they haven't been removed from kwargs super().__init__(**kwargs) calls Triangle's init , but Rectangle doesn't inherit from Triangle so why? Remember the MRO? Let's look at RightPyramid's MRO >>> RightPyramid.__mro__ (<class '__main__.RightPyramid'>, <class '__main__.Square'>, <class '__main__.Rectangle'>, <class '__main__.Triangle'>, <class 'object'>) Even though Rectangle doesn't inherit from Triangle, Triangle is next in the list of classes to search for an init method. You'll notice object is at the end of the list. super().__init__(**kwargs) Multiple Inheritance Alternatives As you can see, multiple inheritance can be useful but also lead to very complicated situations and code that is hard to read. It\u2019s also rare to have objects that neatly inherit everything from more than multiple other objects. If you see yourself beginning to use multiple inheritance and a complicated class hierarchy, it\u2019s worth asking yourself if you can achieve code that is cleaner and easier to understand by using composition instead of inheritance. With composition, you can add very specific functionality to your classes from a specialized, simple class called a mixin. Since this article is focused on inheritance, I won\u2019t go into too much detail on composition and how to wield it in Python, but here\u2019s a short example using VolumeMixin to give specific functionality to our 3D objects\u2014in this case, a volume calculation: class Rectangle: def __init__(self, length, width): self.length = length self.width = width def area(self): return self.length * self.width class Square(Rectangle): def __init__(self, length): super().__init__(length, length) class VolumeMixin: def volume(self): return self.area() * self.height class Cube(VolumeMixin, Square): def __init__(self, length): super().__init__(length) self.height = length def face_area(self): return super().area() def surface_area(self): return super().area() * 6 In this example, the code was reworked to include a mixin called VolumeMixin. The mixin is then used by Cube and gives Cube the ability to calculate its volume, which is shown below: >>> cube = Cube(2) >>> cube.surface_area() 24 >>> cube.volume() 8 A super() Recap In this tutorial, you learned how to supercharge your classes with super(). Your journey started with a review of single inheritance and then showed how to call superclass methods easily with super(). You then learned how multiple inheritance works in Python, and techniques to combine super() with multiple inheritance. You also learned about how Python resolves method calls using the method resolution order (MRO), as well as how to inspect and modify the MRO to ensure appropriate methods are called at appropriate times. For more information about object-oriented programming in Python and using super(), check out these resources: Official super() documentation Python\u2019s super() Considered Super by Raymond Hettinger Object-Oriented Programming in Python 3","title":"Multiple Inheritance and Composition"},{"location":"python/advanced/Decorators/","text":"Decorators @Add_This_Functionality_To_Any_Function! Simple Example: def my_decorator(original_function): def new_function(*args,**kwargs): print(\"you did it!\") of = original_function(*args,**kwargs) return of return new_function @my_decorator def my_func1(stuff): print(\"do things\") @my_decorator def my_func2(stuff): print(\"do things\") @my_decorator def my_func3(stuff): print(\"do things\") my_func1(1);my_func2(1);my_func3(1); Tutorial: We need to discuss global variables and function closure [1] functions: def foo(): return 1; [2] scope a_string = 'this is a string' def foo(): print(locals()) foo() # {} print(globals()) # {..., 'a_string': 'this is a string'} [3] varible resolution rules Local variables with the same name as global ones don't modify the global one. [4] variable lifetime def foo(): x = 1; foo() # NameError: name 'x' is not defined [5] function arguments and parameters def foo(x): print(locals()) foo(1) # {'x': 1} def foo(x, y=0): # remember if no default it's mandatory return x - y foo() # Traceback (most recent call last): # File \"\", line 1, in # TypeError: foo() missing 1 required positional argument: 'x' [6] Nested Functions def outer(): x = 1 def inner(): print(x) inner() outer() # 1 [7] Functions are first class objectsin python # all objects in Python inherit from a common baseclass issubclass(int, object) # True def foo(): pass foo.__class__ # <type 'function'> issubclass(foo.__class__, object) # True #..so what? def add(x,y): return x + y def sub(x,y): return x - y def apply(func, x, y): return func(x, y) apply(add, 2, 1) # 3 apply(sub, 2, 1) # 1 #.. closure lead in def outer(): def inner(): print('this is inner') return inner # the function not what it returns foo = outer() foo # .inner at 0x10be011e0> foo() # 'this is inner' [8] Closures def outer(): x = 1 def inner(): print(x) return inner # the function not what it returns foo = outer() foo.__closure__ # (,) # aside: cell objects are used to store the free variables of a closure # without closures x would have not existed as after the call to outer x is gone based on variable life time. # inner functions defined in non-global scope remember what their enclosing namespaces looked like at definition time. foo() # 1 # let's tweak it def outer(x): def inner(): print(x) return inner print1 = outer(1) print2 = outer(2) print1() # 1 print2() # 2 [9] Decorators def outer(some_func): def inner(): print('before some_func') ret = some_func() # 1 return ret + 1 return inner def foo(): return 1 decorated = outer(foo) decorated() # we've added functionality to foo()! # what if we did this foo = outer(foo) foo() # before some_func # 2 # Let's write a more useful decorator class Coordinate(object): def __init__(self, x, y): self.x = x self.y = y def __repr__(self): return \"Coord: \" + str(self.__dict__) def add(a, b): return Coordinate(a.x + b.x, a.y + b.y) def sub(a, b): return Coordinate(a.x - b.x, a.y - b.y) one = Coordinate(100, 200) two = Coordinate(300, 200) add(one, two) # Coord: {'y': 400, 'x': 400} # add this instance three = Coordinate(-100, -100) def wrapper(func): def checker(a, b): # 1 if a.x < 0 or a.y < 0: a = Coordinate(a.x if a.x > 0 else 0, a.y if a.y > 0 else 0) if b.x < 0 or b.y < 0: b = Coordinate(b.x if b.x > 0 else 0, b.y if b.y > 0 else 0) ret = func(a, b) if ret.x < 0 or ret.y < 0: ret = Coordinate(ret.x if ret.x > 0 else 0, ret.y if ret.y > 0 else 0) return ret return checker add = wrapper(add) sub = wrapper(sub) sub(one, two) add(one, three) [10] the @ symbol # so instead of wrapper(add)\\wrapper(sub), use @wrapper @wrapper def add(a, b): return Coordinate(a.x + b.x, a.y + b.y) @wrapper def sub(a, b): return Coordinate(a.x - b.x, a.y - b.y) [11] *args and **kwargs def one(*args): print(args) one() # () one(1,2,3) # (1, 2, 3) def two(x, y, *args): print(x, y, args) two('a','b','c') # Reminder # l = (1,2,3) # one(l[0], l[1], l[2]) # (1, 2, 3) # one(*l) # (1, 2, 3) def foo(**kwargs): print(kwargs) foo() foo(x=1, y=2) [12] More generic decorators def logger(func): def inner(*args, **kwargs): print('Arguments were: {}, {}'.format(args,kwargs)) return func(*args, **kwargs) return inner @logger def foo1(x,y=1): return x * y @logger def foo2(): return 2 foo1(5,4) # Arguments were: (5, 4), {} # 20 foo2() # Arguments were: (), {} # 2","title":"Decorators"},{"location":"python/advanced/Decorators/#decorators","text":"@Add_This_Functionality_To_Any_Function!","title":"Decorators"},{"location":"python/advanced/Decorators/#simple-example","text":"def my_decorator(original_function): def new_function(*args,**kwargs): print(\"you did it!\") of = original_function(*args,**kwargs) return of return new_function @my_decorator def my_func1(stuff): print(\"do things\") @my_decorator def my_func2(stuff): print(\"do things\") @my_decorator def my_func3(stuff): print(\"do things\") my_func1(1);my_func2(1);my_func3(1);","title":"Simple Example:"},{"location":"python/advanced/Decorators/#tutorial","text":"We need to discuss global variables and function closure","title":"Tutorial:"},{"location":"python/advanced/Decorators/#1-functions","text":"def foo(): return 1;","title":"[1] functions:"},{"location":"python/advanced/Decorators/#2-scope","text":"a_string = 'this is a string' def foo(): print(locals()) foo() # {} print(globals()) # {..., 'a_string': 'this is a string'}","title":"[2] scope"},{"location":"python/advanced/Decorators/#3-varible-resolution-rules","text":"Local variables with the same name as global ones don't modify the global one.","title":"[3] varible resolution rules"},{"location":"python/advanced/Decorators/#4-variable-lifetime","text":"def foo(): x = 1; foo() # NameError: name 'x' is not defined","title":"[4] variable lifetime"},{"location":"python/advanced/Decorators/#5-function-arguments-and-parameters","text":"def foo(x): print(locals()) foo(1) # {'x': 1} def foo(x, y=0): # remember if no default it's mandatory return x - y foo() # Traceback (most recent call last): # File \"\", line 1, in # TypeError: foo() missing 1 required positional argument: 'x'","title":"[5] function arguments and parameters"},{"location":"python/advanced/Decorators/#6-nested-functions","text":"def outer(): x = 1 def inner(): print(x) inner() outer() # 1","title":"[6] Nested Functions"},{"location":"python/advanced/Decorators/#7-functions-are-first-class-objectsin-python","text":"# all objects in Python inherit from a common baseclass issubclass(int, object) # True def foo(): pass foo.__class__ # <type 'function'> issubclass(foo.__class__, object) # True #..so what? def add(x,y): return x + y def sub(x,y): return x - y def apply(func, x, y): return func(x, y) apply(add, 2, 1) # 3 apply(sub, 2, 1) # 1 #.. closure lead in def outer(): def inner(): print('this is inner') return inner # the function not what it returns foo = outer() foo # .inner at 0x10be011e0> foo() # 'this is inner'","title":"[7] Functions are first class objectsin python"},{"location":"python/advanced/Decorators/#8-closures","text":"def outer(): x = 1 def inner(): print(x) return inner # the function not what it returns foo = outer() foo.__closure__ # (,) # aside: cell objects are used to store the free variables of a closure # without closures x would have not existed as after the call to outer x is gone based on variable life time. # inner functions defined in non-global scope remember what their enclosing namespaces looked like at definition time. foo() # 1 # let's tweak it def outer(x): def inner(): print(x) return inner print1 = outer(1) print2 = outer(2) print1() # 1 print2() # 2","title":"[8] Closures"},{"location":"python/advanced/Decorators/#9-decorators","text":"def outer(some_func): def inner(): print('before some_func') ret = some_func() # 1 return ret + 1 return inner def foo(): return 1 decorated = outer(foo) decorated() # we've added functionality to foo()! # what if we did this foo = outer(foo) foo() # before some_func # 2 # Let's write a more useful decorator class Coordinate(object): def __init__(self, x, y): self.x = x self.y = y def __repr__(self): return \"Coord: \" + str(self.__dict__) def add(a, b): return Coordinate(a.x + b.x, a.y + b.y) def sub(a, b): return Coordinate(a.x - b.x, a.y - b.y) one = Coordinate(100, 200) two = Coordinate(300, 200) add(one, two) # Coord: {'y': 400, 'x': 400} # add this instance three = Coordinate(-100, -100) def wrapper(func): def checker(a, b): # 1 if a.x < 0 or a.y < 0: a = Coordinate(a.x if a.x > 0 else 0, a.y if a.y > 0 else 0) if b.x < 0 or b.y < 0: b = Coordinate(b.x if b.x > 0 else 0, b.y if b.y > 0 else 0) ret = func(a, b) if ret.x < 0 or ret.y < 0: ret = Coordinate(ret.x if ret.x > 0 else 0, ret.y if ret.y > 0 else 0) return ret return checker add = wrapper(add) sub = wrapper(sub) sub(one, two) add(one, three)","title":"[9] Decorators"},{"location":"python/advanced/Decorators/#10-the-symbol","text":"# so instead of wrapper(add)\\wrapper(sub), use @wrapper @wrapper def add(a, b): return Coordinate(a.x + b.x, a.y + b.y) @wrapper def sub(a, b): return Coordinate(a.x - b.x, a.y - b.y)","title":"[10] the @ symbol"},{"location":"python/advanced/Decorators/#11-42args-and-4242kwargs","text":"def one(*args): print(args) one() # () one(1,2,3) # (1, 2, 3) def two(x, y, *args): print(x, y, args) two('a','b','c') # Reminder # l = (1,2,3) # one(l[0], l[1], l[2]) # (1, 2, 3) # one(*l) # (1, 2, 3) def foo(**kwargs): print(kwargs) foo() foo(x=1, y=2)","title":"[11] *args and **kwargs"},{"location":"python/advanced/Decorators/#12-more-generic-decorators","text":"def logger(func): def inner(*args, **kwargs): print('Arguments were: {}, {}'.format(args,kwargs)) return func(*args, **kwargs) return inner @logger def foo1(x,y=1): return x * y @logger def foo2(): return 2 foo1(5,4) # Arguments were: (5, 4), {} # 20 foo2() # Arguments were: (), {} # 2","title":"[12] More generic decorators"},{"location":"python/advanced/Generators/","text":"Generators A simplified Iterator Quick Example: def all_even(): n = 0 while True: yield n n += 2 x = all_even() print(next(x)) # 0 print(next(x)) # 2 print(next(x)) # 4 #.... forever What are generators in Python? There is a lot of overhead in building an iterator in Python; we have to implement a class with iter () and next () method, keep track of internal states, raise StopIteration when there was no values to be returned etc. This is both lengthy and counter intuitive. Generator comes into rescue in such situations. Python generators are a simple way of creating iterators. All the overhead we mentioned above are automatically handled by generators in Python. Simply speaking, a generator is a function that returns an object (iterator) which we can iterate over (one value at a time). How to create a generator in Python? It is fairly simple to create a generator in Python. It is as easy as defining a normal function with yield statement instead of a return statement. If a function contains at least one yield statement (it may contain other yield or return statements), it becomes a generator function. Both yield and return will return some value from a function. The difference is that, while a return statement terminates a function entirely, yield statement pauses the function saving all its states and later continues from there on successive calls. Differences between Generator function and a Normal function Generator function contains one or more yield statement. When called, it returns an object (iterator) but does not start execution immediately. Methods like iter () and next () are implemented automatically. So we can iterate through the items using next(). Once the function yields, the function is paused and the control is transferred to the caller. Local variables and their states are remembered between successive calls. Finally, when the function terminates, StopIteration is raised automatically on further calls. Simple Example: # A simple generator function def my_gen(): n = 1 print('This is printed first') # Generator function contains yield statements yield n n += 1 print('This is printed second') yield n n += 1 print('This is printed at last') yield n mg = my_gen() next(mg) # This is printed first next(mg) # This is printed second next(mg) # This is printed third next(mg) # Raises error... One interesting thing to note in the above example is that, the value of variable n is remembered between each call. Unlike normal functions, the local variables are not destroyed when the function yields. Furthermore, the generator object can be iterated only once. To restart the process we need to create another generator object using something like a = my_gen(). Note: One final thing to note is that we can use generators with for loops directly. This is because, a for loop takes an iterator and iterates over it using next() function. It automatically ends when StopIteration is raised. Check here to know how a for loop is actually implemented in Python . Python Generators with a Loop The above example is of less use and we studied it just to get an idea of what was happening in the background. Normally, generator functions are implemented with a loop having a suitable terminating condition. Let's take an example of a generator that reverses a string. def rev_str(my_str): length = len(my_str) for i in range(length - 1,-1,-1): yield my_str[i] # For loop to reverse the string # Output: # o # l # l # e # h for char in rev_str(\"hello\"): print(char) In this example, we use range() function to get the index in reverse order using the for loop. It turns out that this generator function not only works with string, but also with other kind of iterables like list, tuple etc. Python Generator Expression Simple generators can be easily created on the fly using generator expressions. It makes building generators easy. Same as lambda function creates an anonymous function, generator expression creates an anonymous generator function. The syntax for generator expression is similar to that of a list comprehension in Python. But the square brackets are replaced with round parentheses. The major difference between a list comprehension and a generator expression is that while list comprehension produces the entire list, generator expression produces one item at a time. They are kind of lazy, producing items only when asked for. For this reason, a generator expression is much more memory efficient than an equivalent list comprehension. # Initialize the list my_list = [1, 3, 6, 10] # square each term using list comprehension # Output: [1, 9, 36, 100] [x**2 for x in my_list] # same thing can be done using generator expression # Output: at 0x0000000002EBDAF8> y = (x**2 for x in my_list) print(next(y)) # 1 print(next(y)) # 9 print(next(y)) # 36 print(next(y)) # 100 print(next(y)) # error Generator expression can be used inside functions. When used in such a way, the round parentheses can be dropped. >>> sum(x**2 for x in my_list) 146 >>> max(x**2 for x in my_list) 100 Why generators are used in Python? Easy to Implement: Generators can be implemented in a clear and concise way as compared to their iterator class counterpart. Following is an example to implement a sequence of power of 2's using iterator class. class PowTwo: def __init__(self, max = 0): self.max = max def __iter__(self): self.n = 0 return self def __next__(self): if self.n > self.max: raise StopIteration result = 2 ** self.n self.n += 1 return result This was lengthy. Now lets do the same using a generator function. def PowTwoGen(max = 0): n = 0 while n < max: yield 2 ** n n += 1 Memory Efficient: A normal function to return a sequence will create the entire sequence in memory before returning the result. This is an overkill if the number of items in the sequence is very large. Generator implementation of such sequence is memory friendly and is preferred since it only produces one item at a time. Represent Infinite Stream: Generators are excellent medium to represent an infinite stream of data. Infinite streams cannot be stored in memory and since generators produce only one item at a time, it can represent infinite stream of data. The following example can generate all the even numbers (at least in theory). def all_even(): n = 0 while True: yield n n += 2 Pipelining Generators: Generators can be used to pipeline a series of operations. This is best illustrated using an example. Suppose we have a log file from a famous fast food chain. The log file has a column (4th column) that keeps track of the number of pizza sold every hour and we want to sum it to find the total pizzas sold in 5 years. Assume everything is in string and numbers that are not available are marked as 'N/A'. A generator implementation of this could be as follows. # - sells.log - # # 1 2 3 1 # 1 2 3 2 # 1 2 3 3 # 1 2 3 4 # 1 2 3 5 # 1 2 3 6 # 1 2 3 7 # 1 2 3 8 # 1 2 3 9 # 1 2 3 10 # - - # with open('sells.log') as file: pizza_col = (line.split()[3] for line in file) per_hour = (int(x) for x in pizza_col if x != 'N/A') print(\"Total pizzas sold = \",sum(per_hour)) This pipelining is efficient and easy to read (and yes, a lot cooler!).","title":"Generators"},{"location":"python/advanced/Generators/#generators","text":"A simplified Iterator","title":"Generators"},{"location":"python/advanced/Generators/#quick-example","text":"def all_even(): n = 0 while True: yield n n += 2 x = all_even() print(next(x)) # 0 print(next(x)) # 2 print(next(x)) # 4 #.... forever","title":"Quick Example:"},{"location":"python/advanced/Generators/#what-are-generators-in-python","text":"There is a lot of overhead in building an iterator in Python; we have to implement a class with iter () and next () method, keep track of internal states, raise StopIteration when there was no values to be returned etc. This is both lengthy and counter intuitive. Generator comes into rescue in such situations. Python generators are a simple way of creating iterators. All the overhead we mentioned above are automatically handled by generators in Python. Simply speaking, a generator is a function that returns an object (iterator) which we can iterate over (one value at a time).","title":"What are generators in Python?"},{"location":"python/advanced/Generators/#how-to-create-a-generator-in-python","text":"It is fairly simple to create a generator in Python. It is as easy as defining a normal function with yield statement instead of a return statement. If a function contains at least one yield statement (it may contain other yield or return statements), it becomes a generator function. Both yield and return will return some value from a function. The difference is that, while a return statement terminates a function entirely, yield statement pauses the function saving all its states and later continues from there on successive calls.","title":"How to create a generator in Python?"},{"location":"python/advanced/Generators/#differences-between-generator-function-and-a-normal-function","text":"Generator function contains one or more yield statement. When called, it returns an object (iterator) but does not start execution immediately. Methods like iter () and next () are implemented automatically. So we can iterate through the items using next(). Once the function yields, the function is paused and the control is transferred to the caller. Local variables and their states are remembered between successive calls. Finally, when the function terminates, StopIteration is raised automatically on further calls. Simple Example: # A simple generator function def my_gen(): n = 1 print('This is printed first') # Generator function contains yield statements yield n n += 1 print('This is printed second') yield n n += 1 print('This is printed at last') yield n mg = my_gen() next(mg) # This is printed first next(mg) # This is printed second next(mg) # This is printed third next(mg) # Raises error... One interesting thing to note in the above example is that, the value of variable n is remembered between each call. Unlike normal functions, the local variables are not destroyed when the function yields. Furthermore, the generator object can be iterated only once. To restart the process we need to create another generator object using something like a = my_gen(). Note: One final thing to note is that we can use generators with for loops directly. This is because, a for loop takes an iterator and iterates over it using next() function. It automatically ends when StopIteration is raised. Check here to know how a for loop is actually implemented in Python .","title":"Differences between Generator function and a Normal function"},{"location":"python/advanced/Generators/#python-generators-with-a-loop","text":"The above example is of less use and we studied it just to get an idea of what was happening in the background. Normally, generator functions are implemented with a loop having a suitable terminating condition. Let's take an example of a generator that reverses a string. def rev_str(my_str): length = len(my_str) for i in range(length - 1,-1,-1): yield my_str[i] # For loop to reverse the string # Output: # o # l # l # e # h for char in rev_str(\"hello\"): print(char) In this example, we use range() function to get the index in reverse order using the for loop. It turns out that this generator function not only works with string, but also with other kind of iterables like list, tuple etc.","title":"Python Generators with a Loop"},{"location":"python/advanced/Generators/#python-generator-expression","text":"Simple generators can be easily created on the fly using generator expressions. It makes building generators easy. Same as lambda function creates an anonymous function, generator expression creates an anonymous generator function. The syntax for generator expression is similar to that of a list comprehension in Python. But the square brackets are replaced with round parentheses. The major difference between a list comprehension and a generator expression is that while list comprehension produces the entire list, generator expression produces one item at a time. They are kind of lazy, producing items only when asked for. For this reason, a generator expression is much more memory efficient than an equivalent list comprehension. # Initialize the list my_list = [1, 3, 6, 10] # square each term using list comprehension # Output: [1, 9, 36, 100] [x**2 for x in my_list] # same thing can be done using generator expression # Output: at 0x0000000002EBDAF8> y = (x**2 for x in my_list) print(next(y)) # 1 print(next(y)) # 9 print(next(y)) # 36 print(next(y)) # 100 print(next(y)) # error Generator expression can be used inside functions. When used in such a way, the round parentheses can be dropped. >>> sum(x**2 for x in my_list) 146 >>> max(x**2 for x in my_list) 100","title":"Python Generator Expression"},{"location":"python/advanced/Generators/#why-generators-are-used-in-python","text":"Easy to Implement: Generators can be implemented in a clear and concise way as compared to their iterator class counterpart. Following is an example to implement a sequence of power of 2's using iterator class. class PowTwo: def __init__(self, max = 0): self.max = max def __iter__(self): self.n = 0 return self def __next__(self): if self.n > self.max: raise StopIteration result = 2 ** self.n self.n += 1 return result This was lengthy. Now lets do the same using a generator function. def PowTwoGen(max = 0): n = 0 while n < max: yield 2 ** n n += 1 Memory Efficient: A normal function to return a sequence will create the entire sequence in memory before returning the result. This is an overkill if the number of items in the sequence is very large. Generator implementation of such sequence is memory friendly and is preferred since it only produces one item at a time. Represent Infinite Stream: Generators are excellent medium to represent an infinite stream of data. Infinite streams cannot be stored in memory and since generators produce only one item at a time, it can represent infinite stream of data. The following example can generate all the even numbers (at least in theory). def all_even(): n = 0 while True: yield n n += 2 Pipelining Generators: Generators can be used to pipeline a series of operations. This is best illustrated using an example. Suppose we have a log file from a famous fast food chain. The log file has a column (4th column) that keeps track of the number of pizza sold every hour and we want to sum it to find the total pizzas sold in 5 years. Assume everything is in string and numbers that are not available are marked as 'N/A'. A generator implementation of this could be as follows. # - sells.log - # # 1 2 3 1 # 1 2 3 2 # 1 2 3 3 # 1 2 3 4 # 1 2 3 5 # 1 2 3 6 # 1 2 3 7 # 1 2 3 8 # 1 2 3 9 # 1 2 3 10 # - - # with open('sells.log') as file: pizza_col = (line.split()[3] for line in file) per_hour = (int(x) for x in pizza_col if x != 'N/A') print(\"Total pizzas sold = \",sum(per_hour)) This pipelining is efficient and easy to read (and yes, a lot cooler!).","title":"Why generators are used in Python?"},{"location":"python/base_modules/collections/Counter/","text":"Counter Counter is a dict subclass for counting hashable objects: >>> c = Counter() # a new, empty counter >>> c Counter() >>> c = Counter('gallahad') # a new counter from an iterable >>> c Counter({'a': 3, 'l': 2, 'g': 1, 'h': 1, 'd': 1}) # a new counter from a mapping >>> c = Counter({'red': 4, 'blue': 2}) # a new counter from a mapping >>> c Counter({'red': 4, 'blue': 2}) >>> c = Counter(cats=4, dogs=8) # a new counter from keyword args >>> c Counter({'dogs': 8, 'cats': 4}) >>> Counter([1,2,2,3,3,3,4,4,4,4]) Counter({4: 4, 3: 3, 2: 2, 1: 1}) Delete objects as shown below: # Delete records as shown below: >>> c = Counter(['eggs', 'ham']) >>> c Counter({'eggs': 1, 'ham': 1}) >>> del c['ham'] >>> c Counter({'eggs': 1}) Counter objects support three methods beyond those available for all dictionaries: elements() Return an iterator over elements repeating each as many times as its count. Elements are returned in arbitrary order. If an element\u2019s count is less than one, elements() will ignore it. >>> c = Counter(a=4, b=2, c=0, d=-2) >>> list(c.elements()) ['a', 'a', 'a', 'a', 'b', 'b'] most_common([n]) Return a list of the n most common elements and their counts from the most common to the least. If n is omitted or None, most_common() returns all elements in the counter. Elements with equal counts are ordered arbitrarily: >>> Counter('abracadabra').most_common(3) [('a', 5), ('r', 2), ('b', 2)] subtract([iterable-or-mapping]) Elements are subtracted from an iterable or from another mapping (or counter). Like dict.update() but subtracts counts instead of replacing them. Both inputs and outputs may be zero or negative. >>> c = Counter(a=4, b=2, c=0, d=-2) >>> d = Counter(a=1, b=2, c=3, d=4) >>> c.subtract(d) >>> c Counter({'a': 3, 'b': 0, 'c': -3, 'd': -6})","title":"Counter"},{"location":"python/base_modules/collections/Counter/#counter","text":"Counter is a dict subclass for counting hashable objects: >>> c = Counter() # a new, empty counter >>> c Counter() >>> c = Counter('gallahad') # a new counter from an iterable >>> c Counter({'a': 3, 'l': 2, 'g': 1, 'h': 1, 'd': 1}) # a new counter from a mapping >>> c = Counter({'red': 4, 'blue': 2}) # a new counter from a mapping >>> c Counter({'red': 4, 'blue': 2}) >>> c = Counter(cats=4, dogs=8) # a new counter from keyword args >>> c Counter({'dogs': 8, 'cats': 4}) >>> Counter([1,2,2,3,3,3,4,4,4,4]) Counter({4: 4, 3: 3, 2: 2, 1: 1})","title":"Counter"},{"location":"python/base_modules/collections/Counter/#delete-objects-as-shown-below","text":"# Delete records as shown below: >>> c = Counter(['eggs', 'ham']) >>> c Counter({'eggs': 1, 'ham': 1}) >>> del c['ham'] >>> c Counter({'eggs': 1}) Counter objects support three methods beyond those available for all dictionaries:","title":"Delete objects as shown below:"},{"location":"python/base_modules/collections/Counter/#elements","text":"Return an iterator over elements repeating each as many times as its count. Elements are returned in arbitrary order. If an element\u2019s count is less than one, elements() will ignore it. >>> c = Counter(a=4, b=2, c=0, d=-2) >>> list(c.elements()) ['a', 'a', 'a', 'a', 'b', 'b']","title":"elements()"},{"location":"python/base_modules/collections/Counter/#most_commonn","text":"Return a list of the n most common elements and their counts from the most common to the least. If n is omitted or None, most_common() returns all elements in the counter. Elements with equal counts are ordered arbitrarily: >>> Counter('abracadabra').most_common(3) [('a', 5), ('r', 2), ('b', 2)]","title":"most_common([n])"},{"location":"python/base_modules/collections/Counter/#subtractiterable-or-mapping","text":"Elements are subtracted from an iterable or from another mapping (or counter). Like dict.update() but subtracts counts instead of replacing them. Both inputs and outputs may be zero or negative. >>> c = Counter(a=4, b=2, c=0, d=-2) >>> d = Counter(a=1, b=2, c=3, d=4) >>> c.subtract(d) >>> c Counter({'a': 3, 'b': 0, 'c': -3, 'd': -6})","title":"subtract([iterable-or-mapping])"},{"location":"python/base_modules/collections/Default Dict/","text":"Default Dict Initialize dictionary values with a data type. Returns a new dictionary-like object. defaultdict is a subclass of the built-in dict class. The first argument provides the initial value for the default_factory attribute; it defaults to None . All remaining arguments are treated the same as if they were passed to the dict constructor, including keyword arguments. from collections import defaultdict # Try to append all numbers in a list to their descriptions s = [('yellow', 1), ('blue', 2), ('yellow', 3), ('blue', 4), ('red', 1)] d = {} for k, v in s: d[k].append(v) # You can't because there is no default data type for the values of the keys being created. >>> Traceback (most recent call last): File \"\", line 1, in File \"\", line 6, in KeyError: 'yellow' # Use a default dict to accomplish this: s = [('yellow', 1), ('blue', 2), ('yellow', 3), ('blue', 4), ('red', 1)] d = defaultdict(list) for k, v in s: d[k].append(v) >>> d defaultdict(, {'yellow': [1, 3], 'blue': [2, 4], 'red': [1]}) # You can accomplish this with the base dictionary like this: >>> d = {} >>> d.setdefault('yellow', []) [] >>> d {'yellow': []} or >>> d = {} >>> d.setdefault('yellow', list) >>> d {'yellow': } # ...and our previous example: s = [('yellow', 1), ('blue', 2), ('yellow', 3), ('blue', 4), ('red', 1)] d = {} for k, v in s: d.setdefault(k, []).append(v) >>> d {'yellow': [1, 3], 'blue': [2, 4], 'red': [1]}","title":"default_dict()"},{"location":"python/base_modules/collections/Default Dict/#default-dict","text":"Initialize dictionary values with a data type. Returns a new dictionary-like object. defaultdict is a subclass of the built-in dict class. The first argument provides the initial value for the default_factory attribute; it defaults to None . All remaining arguments are treated the same as if they were passed to the dict constructor, including keyword arguments. from collections import defaultdict # Try to append all numbers in a list to their descriptions s = [('yellow', 1), ('blue', 2), ('yellow', 3), ('blue', 4), ('red', 1)] d = {} for k, v in s: d[k].append(v) # You can't because there is no default data type for the values of the keys being created. >>> Traceback (most recent call last): File \"\", line 1, in File \"\", line 6, in KeyError: 'yellow' # Use a default dict to accomplish this: s = [('yellow', 1), ('blue', 2), ('yellow', 3), ('blue', 4), ('red', 1)] d = defaultdict(list) for k, v in s: d[k].append(v) >>> d defaultdict(, {'yellow': [1, 3], 'blue': [2, 4], 'red': [1]}) # You can accomplish this with the base dictionary like this: >>> d = {} >>> d.setdefault('yellow', []) [] >>> d {'yellow': []} or >>> d = {} >>> d.setdefault('yellow', list) >>> d {'yellow': } # ...and our previous example: s = [('yellow', 1), ('blue', 2), ('yellow', 3), ('blue', 4), ('red', 1)] d = {} for k, v in s: d.setdefault(k, []).append(v) >>> d {'yellow': [1, 3], 'blue': [2, 4], 'red': [1]}","title":"Default Dict"},{"location":"python/strings/Strings/","text":"Strings Padding: center(), rjust(), ljust() The center() method returns a string which is padded with the specified character. The rjust()\\ljust() methods return a string which is padded on either side. >>> 'A'.center(1, '*') 'A' >>> 'A'.center(2, '*') 'A*' >>> 'A'.center(3, '*') '*A*' >>> 'A'.rjust(1, '*') 'A' >>> 'A'.rjust(2, '*') '*A' >>> 'A'.rjust(3, '*') '**A' >>> 'A'.ljust(1, '*') 'A' >>> 'A'.ljust(2, '*') 'A*' >>> 'A'.ljust(3, '*') 'A**' str.format() Different common uses of the str.format() function format(value[, format_spec]) First example: >>> \"{}\".format('value') 'value' Multiple values: >>> \"{} {}\".format('value1','value2') 'value1 value2' Reverse order: >>> \"{1} {0}\".format('value1','value2') 'value2 value1' Key Word Arguments >>> print(\"{kwarg} is {0} used for {1}\" .format(\"being\", \"string formatting\", kwarg =\"Some Key Word Argument\")) ... Some Key Word Argument is being used for string formatting We can also use types to further format values: Syntax: {field_name:conversion}.format(value) Note: field_name can be the index (0) or name of key word argument conversion values: s \u2013 strings d \u2013 decimal integers (base-10) f \u2013 floating point display c \u2013 character b \u2013 binary o \u2013 octal x \u2013 hexadecimal with lowercase letters after 9 X \u2013 hexadecimal with uppercase letters after 9 e \u2013 exponent notation Use like this: s - string >>> '{kwarg:s}'.format(kwarg='5') '5' >>> '{kwarg:s}'.format(kwarg=5) Traceback (most recent call last): File \"\", line 1, in ValueError: Unknown format code 's' for object of type 'int' Notice how we got an error for trying to convert an int to a string d - decimal integers >>> # This works print(\"Convert {0} to decimal integer: {0:d}.\".format(100)) # Notice the Error print(\"Convert {0} to decimal integer: {0:d}.\".format(100.0)) ... Convert 100 to decimal integer: 100. >>> ... Traceback (most recent call last): File \"\", line 2, in ValueError: Unknown format code 'd' for object of type 'float' f - floats >>> # Default decimal precision to 0.000001 print(\"Convert {0} to float: {0:f}.\".format(100.123456789)) ... Convert 100.123456789 to float: 100.123457. >>> # Change decimal precision to 0.01 print(\"Convert {0} to float: {0:.2f}.\".format(100.123456789)) ... Convert 100.123456789 to float: 100.12. >>> # Change decimal precision to 0.1 print(\"Convert {0} to float: {0:.1f}.\".format(100.123456789)) ... Convert 100.123456789 to float: 100.1. >>> # Change decimal precision to 0.000000001 print(\"Convert {0} to float: {0:.9f}.\".format(100.123456789)) ... Convert 100.123456789 to float: 100.123456789. c - single character (accepts integer or single character string). Use this link for a unicode character lookup table Brief sample... NUL SOH STX ETX EOT ENQ ACK BEL BS HT LF VT FF CR SO SI DLE DC1 DC2 DC3 DC4 NAK SYN ETB CAN EM SUB ESC FS GS RS US ! \" # $ % & ' ( ) * + , - . / 0 1 2 3 4 5 6 7 8 9 : ; < = > ? @ A B C D E F G H I J K L M N O P Q R S T U V W X Y Z [ \\ ] ^ _ ... #000 >>> ' '.join(['{0:c}'.format(_) for _ in range(16)]) '\\x00 \\x01 \\x02 \\x03 \\x04 \\x05 \\x06 \\x07 \\x08 \\t \\n \\x0b \\x0c \\r \\x0e \\x0f' #001 >>> ' '.join(['{0:c}'.format(_) for _ in range(16,32)]) '\\x10 \\x11 \\x12 \\x13 \\x14 \\x15 \\x16 \\x17 \\x18 \\x19 \\x1a \\x1b \\x1c \\x1d \\x1e \\x1f' #002 >>> ' '.join(['{0:c}'.format(_) for _ in range(32,48)]) ' ! \" # $ % & \\' ( ) * + , - . /' #003 >>> ' '.join(['{0:c}'.format(_) for _ in range(48,64)]) '0 1 2 3 4 5 6 7 8 9 : ; < = > ?' #004 >>> ' '.join(['{0:c}'.format(_) for _ in range(64,80)]) '@ A B C D E F G H I J K L M N O' #005 >>> ' '.join(['{0:c}'.format(_) for _ in range(80,96)]) 'P Q R S T U V W X Y Z [ \\\\ ] ^ _' b - binary >>> print(\"{0:b}\".format(0)) 0 >>> print(\"{0:b}\".format(1)) 1 >>> print(\"{0:b}\".format(2)) 10 >>> print(\"{0:b}\".format(3)) 11 >>> print(\"{0:b}\".format(100)) 1100100 o - octal >>> print(\"{0:o}\".format(0)) 0 >>> print(\"{0:o}\".format(8)) 10 >>> print(\"{0:o}\".format(8*2)) 20 >>> print(\"{0:o}\".format(8*3)) 30 >>> print(\"{0:o}\".format(8*4)) 40 >>> print(\"{0:o}\".format(8 ** 1)) 10 >>> print(\"{0:o}\".format(8 ** 2)) 100 >>> print(\"{0:o}\".format(8 ** 3)) 1000 x\\H - hex\\HEX print(\"{0:x}\".format(0*16)) # 0 print(\"{0:x}\".format(1*16)) # 10 print(\"{0:x}\".format(2*16)) # 20 print(\"{0:x}\".format(16 ** 1)) # 10 print(\"{0:x}\".format(16 ** 2)) # 100 print(\"{0:x}\".format(16 ** 3)) # 1000 print(\"{0:x}\".format(10)) # a print(\"{0:X}\".format(10)) # A print(\"{0:x}\".format(15)) # f print(\"{0:X}\".format(15)) # F e - exponent print(\"{0:e}\".format(10)) # 1.000000e+01 print(\"{0:e}\".format(100)) # 1.000000e+02 print(\"{0:e}\".format(1000)) # 1.000000e+03 str.find() Use a substring and start-end range to identify where a substring resides in a larger string str.find(sub[, start[, end]]) s = 'ABCBCBCBCBC' # str.find() will return the index found or -1. # with only a start value the rest of the string is searched print(s.find('BC', 0)) # >>> 1 print(s.find('BC', 1)) # >>> 1 print(s.find('BC', 2)) # >>> 3 print(s.find('BC', 3)) # >>> 3 print(s.find('BC', 4)) # >>> 5 print(s.find('BC', 5)) # >>> 5 print(s.find('BC', 6)) # >>> 7 print(s.find('BC', 7)) # >>> 7 print(s.find('BC', 8)) # >>> 9 print(s.find('BC', 9)) # >>> 9 print(s.find('BC', 10)) # >>> -1 # with start and end, the substring must be within the range print(s.find('BC', 0,1)) # >>> -1 print(s.find('BC', 0,2)) # >>> -1 print(s.find('BC', 0,3)) # >>> 1","title":"Strings"},{"location":"python/strings/Strings/#strings","text":"","title":"Strings"},{"location":"python/strings/Strings/#padding-center-rjust-ljust","text":"The center() method returns a string which is padded with the specified character. The rjust()\\ljust() methods return a string which is padded on either side. >>> 'A'.center(1, '*') 'A' >>> 'A'.center(2, '*') 'A*' >>> 'A'.center(3, '*') '*A*' >>> 'A'.rjust(1, '*') 'A' >>> 'A'.rjust(2, '*') '*A' >>> 'A'.rjust(3, '*') '**A' >>> 'A'.ljust(1, '*') 'A' >>> 'A'.ljust(2, '*') 'A*' >>> 'A'.ljust(3, '*') 'A**'","title":"Padding: center(), rjust(), ljust()"},{"location":"python/strings/Strings/#strformat","text":"Different common uses of the str.format() function format(value[, format_spec]) First example: >>> \"{}\".format('value') 'value' Multiple values: >>> \"{} {}\".format('value1','value2') 'value1 value2' Reverse order: >>> \"{1} {0}\".format('value1','value2') 'value2 value1' Key Word Arguments >>> print(\"{kwarg} is {0} used for {1}\" .format(\"being\", \"string formatting\", kwarg =\"Some Key Word Argument\")) ... Some Key Word Argument is being used for string formatting We can also use types to further format values: Syntax: {field_name:conversion}.format(value) Note: field_name can be the index (0) or name of key word argument conversion values: s \u2013 strings d \u2013 decimal integers (base-10) f \u2013 floating point display c \u2013 character b \u2013 binary o \u2013 octal x \u2013 hexadecimal with lowercase letters after 9 X \u2013 hexadecimal with uppercase letters after 9 e \u2013 exponent notation Use like this: s - string >>> '{kwarg:s}'.format(kwarg='5') '5' >>> '{kwarg:s}'.format(kwarg=5) Traceback (most recent call last): File \"\", line 1, in ValueError: Unknown format code 's' for object of type 'int' Notice how we got an error for trying to convert an int to a string d - decimal integers >>> # This works print(\"Convert {0} to decimal integer: {0:d}.\".format(100)) # Notice the Error print(\"Convert {0} to decimal integer: {0:d}.\".format(100.0)) ... Convert 100 to decimal integer: 100. >>> ... Traceback (most recent call last): File \"\", line 2, in ValueError: Unknown format code 'd' for object of type 'float' f - floats >>> # Default decimal precision to 0.000001 print(\"Convert {0} to float: {0:f}.\".format(100.123456789)) ... Convert 100.123456789 to float: 100.123457. >>> # Change decimal precision to 0.01 print(\"Convert {0} to float: {0:.2f}.\".format(100.123456789)) ... Convert 100.123456789 to float: 100.12. >>> # Change decimal precision to 0.1 print(\"Convert {0} to float: {0:.1f}.\".format(100.123456789)) ... Convert 100.123456789 to float: 100.1. >>> # Change decimal precision to 0.000000001 print(\"Convert {0} to float: {0:.9f}.\".format(100.123456789)) ... Convert 100.123456789 to float: 100.123456789. c - single character (accepts integer or single character string). Use this link for a unicode character lookup table Brief sample... NUL SOH STX ETX EOT ENQ ACK BEL BS HT LF VT FF CR SO SI DLE DC1 DC2 DC3 DC4 NAK SYN ETB CAN EM SUB ESC FS GS RS US ! \" # $ % & ' ( ) * + , - . / 0 1 2 3 4 5 6 7 8 9 : ; < = > ? @ A B C D E F G H I J K L M N O P Q R S T U V W X Y Z [ \\ ] ^ _ ... #000 >>> ' '.join(['{0:c}'.format(_) for _ in range(16)]) '\\x00 \\x01 \\x02 \\x03 \\x04 \\x05 \\x06 \\x07 \\x08 \\t \\n \\x0b \\x0c \\r \\x0e \\x0f' #001 >>> ' '.join(['{0:c}'.format(_) for _ in range(16,32)]) '\\x10 \\x11 \\x12 \\x13 \\x14 \\x15 \\x16 \\x17 \\x18 \\x19 \\x1a \\x1b \\x1c \\x1d \\x1e \\x1f' #002 >>> ' '.join(['{0:c}'.format(_) for _ in range(32,48)]) ' ! \" # $ % & \\' ( ) * + , - . /' #003 >>> ' '.join(['{0:c}'.format(_) for _ in range(48,64)]) '0 1 2 3 4 5 6 7 8 9 : ; < = > ?' #004 >>> ' '.join(['{0:c}'.format(_) for _ in range(64,80)]) '@ A B C D E F G H I J K L M N O' #005 >>> ' '.join(['{0:c}'.format(_) for _ in range(80,96)]) 'P Q R S T U V W X Y Z [ \\\\ ] ^ _' b - binary >>> print(\"{0:b}\".format(0)) 0 >>> print(\"{0:b}\".format(1)) 1 >>> print(\"{0:b}\".format(2)) 10 >>> print(\"{0:b}\".format(3)) 11 >>> print(\"{0:b}\".format(100)) 1100100 o - octal >>> print(\"{0:o}\".format(0)) 0 >>> print(\"{0:o}\".format(8)) 10 >>> print(\"{0:o}\".format(8*2)) 20 >>> print(\"{0:o}\".format(8*3)) 30 >>> print(\"{0:o}\".format(8*4)) 40 >>> print(\"{0:o}\".format(8 ** 1)) 10 >>> print(\"{0:o}\".format(8 ** 2)) 100 >>> print(\"{0:o}\".format(8 ** 3)) 1000 x\\H - hex\\HEX print(\"{0:x}\".format(0*16)) # 0 print(\"{0:x}\".format(1*16)) # 10 print(\"{0:x}\".format(2*16)) # 20 print(\"{0:x}\".format(16 ** 1)) # 10 print(\"{0:x}\".format(16 ** 2)) # 100 print(\"{0:x}\".format(16 ** 3)) # 1000 print(\"{0:x}\".format(10)) # a print(\"{0:X}\".format(10)) # A print(\"{0:x}\".format(15)) # f print(\"{0:X}\".format(15)) # F e - exponent print(\"{0:e}\".format(10)) # 1.000000e+01 print(\"{0:e}\".format(100)) # 1.000000e+02 print(\"{0:e}\".format(1000)) # 1.000000e+03","title":"str.format()"},{"location":"python/strings/Strings/#strfind","text":"Use a substring and start-end range to identify where a substring resides in a larger string str.find(sub[, start[, end]]) s = 'ABCBCBCBCBC' # str.find() will return the index found or -1. # with only a start value the rest of the string is searched print(s.find('BC', 0)) # >>> 1 print(s.find('BC', 1)) # >>> 1 print(s.find('BC', 2)) # >>> 3 print(s.find('BC', 3)) # >>> 3 print(s.find('BC', 4)) # >>> 5 print(s.find('BC', 5)) # >>> 5 print(s.find('BC', 6)) # >>> 7 print(s.find('BC', 7)) # >>> 7 print(s.find('BC', 8)) # >>> 9 print(s.find('BC', 9)) # >>> 9 print(s.find('BC', 10)) # >>> -1 # with start and end, the substring must be within the range print(s.find('BC', 0,1)) # >>> -1 print(s.find('BC', 0,2)) # >>> -1 print(s.find('BC', 0,3)) # >>> 1","title":"str.find()"},{"location":"python/useful/Args and Kwargs/","text":"Args and Kwargs Passing unknown amounts of inputs to a function *args - any number of inputs of any data type. They will be referenced in order with indicies being of the form args[0]...etc. **kwargs - The same as above but with key work arguments, so you would be able to access elements by key name. kwargs The * is important as it signifies if args or kwargs are being used. Otherwise this happens: >>> def prac(*args): ... for i in args: ... print(\"This arg is :{}\".format(i)) ... >>> prac([1,2,3,4,5]) This arg is :[1, 2, 3, 4, 5] # ooooops! >>> prac(*[1,2,3,4,5]) This arg is :1 This arg is :2 This arg is :3 This arg is :4 This arg is :5 >>> def prac(**kwargs): ... for k in kwargs.keys(): ... print(kwargs[k]) ... >>> prac(**{'A':1,'B':2}) 1 2 Also note iterables are acceptible inputs: >>> prac(*[1,2,3,4,5]) This arg is :1 This arg is :2 This arg is :3 This arg is :4 This arg is :5 >>> prac(*(1,2,3,4,5)) This arg is :1 This arg is :2 This arg is :3 This arg is :4 This arg is :5 >>> prac(*{1,2,3,4,5}) This arg is :1 This arg is :2 This arg is :3 This arg is :4 This arg is :5 >>> prac(*range(1,6)) This arg is :1 This arg is :2 This arg is :3 This arg is :4 This arg is :5 Below are additional examples def f(*args,**kwargs): print(args, kwargs) l = [1,2,3] t = (4,5,6) d = {'a':7,'b':8,'c':9} f() # () {} f(1,2,3) # (1, 2, 3) {} f(1,2,3,\"groovy\") # (1, 2, 3, 'groovy') {} f(a=1,b=2,c=3) # () {'a': 1, 'c': 3, 'b': 2} f(a=1,b=2,c=3,zzz=\"hi\") # () {'a': 1, 'c': 3, 'b': 2, 'zzz': 'hi'} f(1,2,3,a=1,b=2,c=3) # (1, 2, 3) {'a': 1, 'c': 3, 'b': 2} f(*l,**d) # (1, 2, 3) {'a': 7, 'c': 9, 'b': 8} f(*t,**d) # (4, 5, 6) {'a': 7, 'c': 9, 'b': 8} f(1,2,*t) # (1, 2, 4, 5, 6) {} f(q=\"winning\",**d) # () {'a': 7, 'q': 'winning', 'c': 9, 'b': 8} f(1,2,*t,q=\"winning\",**d) # (1, 2, 4, 5, 6) {'a': 7, 'q': 'winning', 'c': 9, 'b': 8} def f2(arg1,arg2,*args,**kwargs): print(arg1,arg2, args, kwargs) f2(1,2,3) # 1 2 (3,) {} f2(1,2,3,\"groovy\") # 1 2 (3, 'groovy') {} f2(arg1=1,arg2=2,c=3) # 1 2 () {'c': 3} f2(arg1=1,arg2=2,c=3,zzz=\"hi\") # 1 2 () {'c': 3, 'zzz': 'hi'} f2(1,2,3,a=1,b=2,c=3) # 1 2 (3,) {'a': 1, 'c': 3, 'b': 2} f2(*l,**d) # 1 2 (3,) {'a': 7, 'c': 9, 'b': 8} f2(*t,**d) # 4 5 (6,) {'a': 7, 'c': 9, 'b': 8} f2(1,2,*t) # 1 2 (4, 5, 6) {} f2(1,1,q=\"winning\",**d) # 1 1 () {'a': 7, 'q': 'winning', 'c': 9, 'b': 8} f2(1,2,*t,q=\"winning\",**d) # 1 2 (4, 5, 6) {'a': 7, 'q': 'winning', 'c': 9, 'b': 8}","title":"args, kwargs"},{"location":"python/useful/Args and Kwargs/#args-and-kwargs","text":"Passing unknown amounts of inputs to a function *args - any number of inputs of any data type. They will be referenced in order with indicies being of the form args[0]...etc. **kwargs - The same as above but with key work arguments, so you would be able to access elements by key name. kwargs The * is important as it signifies if args or kwargs are being used. Otherwise this happens: >>> def prac(*args): ... for i in args: ... print(\"This arg is :{}\".format(i)) ... >>> prac([1,2,3,4,5]) This arg is :[1, 2, 3, 4, 5] # ooooops! >>> prac(*[1,2,3,4,5]) This arg is :1 This arg is :2 This arg is :3 This arg is :4 This arg is :5 >>> def prac(**kwargs): ... for k in kwargs.keys(): ... print(kwargs[k]) ... >>> prac(**{'A':1,'B':2}) 1 2 Also note iterables are acceptible inputs: >>> prac(*[1,2,3,4,5]) This arg is :1 This arg is :2 This arg is :3 This arg is :4 This arg is :5 >>> prac(*(1,2,3,4,5)) This arg is :1 This arg is :2 This arg is :3 This arg is :4 This arg is :5 >>> prac(*{1,2,3,4,5}) This arg is :1 This arg is :2 This arg is :3 This arg is :4 This arg is :5 >>> prac(*range(1,6)) This arg is :1 This arg is :2 This arg is :3 This arg is :4 This arg is :5 Below are additional examples def f(*args,**kwargs): print(args, kwargs) l = [1,2,3] t = (4,5,6) d = {'a':7,'b':8,'c':9} f() # () {} f(1,2,3) # (1, 2, 3) {} f(1,2,3,\"groovy\") # (1, 2, 3, 'groovy') {} f(a=1,b=2,c=3) # () {'a': 1, 'c': 3, 'b': 2} f(a=1,b=2,c=3,zzz=\"hi\") # () {'a': 1, 'c': 3, 'b': 2, 'zzz': 'hi'} f(1,2,3,a=1,b=2,c=3) # (1, 2, 3) {'a': 1, 'c': 3, 'b': 2} f(*l,**d) # (1, 2, 3) {'a': 7, 'c': 9, 'b': 8} f(*t,**d) # (4, 5, 6) {'a': 7, 'c': 9, 'b': 8} f(1,2,*t) # (1, 2, 4, 5, 6) {} f(q=\"winning\",**d) # () {'a': 7, 'q': 'winning', 'c': 9, 'b': 8} f(1,2,*t,q=\"winning\",**d) # (1, 2, 4, 5, 6) {'a': 7, 'q': 'winning', 'c': 9, 'b': 8} def f2(arg1,arg2,*args,**kwargs): print(arg1,arg2, args, kwargs) f2(1,2,3) # 1 2 (3,) {} f2(1,2,3,\"groovy\") # 1 2 (3, 'groovy') {} f2(arg1=1,arg2=2,c=3) # 1 2 () {'c': 3} f2(arg1=1,arg2=2,c=3,zzz=\"hi\") # 1 2 () {'c': 3, 'zzz': 'hi'} f2(1,2,3,a=1,b=2,c=3) # 1 2 (3,) {'a': 1, 'c': 3, 'b': 2} f2(*l,**d) # 1 2 (3,) {'a': 7, 'c': 9, 'b': 8} f2(*t,**d) # 4 5 (6,) {'a': 7, 'c': 9, 'b': 8} f2(1,2,*t) # 1 2 (4, 5, 6) {} f2(1,1,q=\"winning\",**d) # 1 1 () {'a': 7, 'q': 'winning', 'c': 9, 'b': 8} f2(1,2,*t,q=\"winning\",**d) # 1 2 (4, 5, 6) {'a': 7, 'q': 'winning', 'c': 9, 'b': 8}","title":"Args and Kwargs"},{"location":"python/useful/Input/","text":"Input Here we show how to accept user input print('Enter your name:') x = input() print('Hello, ' + x) >>> Enter your name: Ben Hello, Ben","title":"input()"},{"location":"python/useful/Input/#input","text":"Here we show how to accept user input print('Enter your name:') x = input() print('Hello, ' + x) >>> Enter your name: Ben Hello, Ben","title":"Input"},{"location":"python/useful/Map/","text":"Map map() allows us to apply a function to a list of items # Simple Example >>> list(map(float, ['1.0', '2.0'])) [1.0, 2.0] # Turn this: items = [1, 2, 3, 4, 5] squared = [] for i in items: squared.append(i**2) # Into this with a lambda function: items = [1, 2, 3, 4, 5] squared = list(map(lambda x: x**2, items))","title":"map()"},{"location":"python/useful/Map/#map","text":"map() allows us to apply a function to a list of items # Simple Example >>> list(map(float, ['1.0', '2.0'])) [1.0, 2.0] # Turn this: items = [1, 2, 3, 4, 5] squared = [] for i in items: squared.append(i**2) # Into this with a lambda function: items = [1, 2, 3, 4, 5] squared = list(map(lambda x: x**2, items))","title":"Map"},{"location":"python/useful/Pass By Reference/","text":"Pass By Reference Python will pass values between objects as references to their memory position. Addresses not values are passed...except for primitives.. An example: def f(x,l=[]): for i in range(x): l.append(i*i) print(l) f(2) # [0, 1] f(3,[3,2,1]) # [3, 2, 1, 0, 1, 4] Here python treats the variable l as a fresh list because a fresh list or more accurately, it's location in memory was passed. See python created [3, 2, 1] separately and passed it's location to the function. Watch what happends when we call the function again with no list. f(3) # [0, 1, 0, 1, 4] why not [0,1,4]?. When the function was first called we created the default list \"l=[]\", and according to the function's directions, by default this function refers to that list's memory position. Check out the following examples of pythons memory usage for this example: l_mem = [] l = l_mem # the first call for i in range(2): l.append(i*i) print(l) # [0, 1] l = [3,2,1] # the second call for i in range(3): l.append(i*i) print(l) # [3, 2, 1, 0, 1, 4] l = l_mem # the third call for i in range(3): l.append(i*i) print(l) # [0, 1, 0, 1, 4]","title":"P.B. Reference"},{"location":"python/useful/Pass By Reference/#pass-by-reference","text":"Python will pass values between objects as references to their memory position. Addresses not values are passed...except for primitives.. An example: def f(x,l=[]): for i in range(x): l.append(i*i) print(l) f(2) # [0, 1] f(3,[3,2,1]) # [3, 2, 1, 0, 1, 4] Here python treats the variable l as a fresh list because a fresh list or more accurately, it's location in memory was passed. See python created [3, 2, 1] separately and passed it's location to the function. Watch what happends when we call the function again with no list. f(3) # [0, 1, 0, 1, 4] why not [0,1,4]?. When the function was first called we created the default list \"l=[]\", and according to the function's directions, by default this function refers to that list's memory position. Check out the following examples of pythons memory usage for this example: l_mem = [] l = l_mem # the first call for i in range(2): l.append(i*i) print(l) # [0, 1] l = [3,2,1] # the second call for i in range(3): l.append(i*i) print(l) # [3, 2, 1, 0, 1, 4] l = l_mem # the third call for i in range(3): l.append(i*i) print(l) # [0, 1, 0, 1, 4]","title":"Pass By Reference"},{"location":"python/useful/Sets/","text":"Sets Sets In Python A Set is an unordered collection data type that is iterable, mutable, and has no duplicate elements. Python\u2019s set class represents the mathematical notion of a set. The major advantage of using a set, as opposed to a list, is that it has a highly optimized method for checking whether a specific element is contained in the set. This is based on a data structure known as a hash table. Methods: add() add(x) Method: Adds the item x to set if it is not already present in the set. >>> s3.add(9) >>> s3 {9, 3} 2. union(s) Method: Returns a union of two set.Using the \u2018|\u2019 operator between 2 sets is the same as writing set1.union(set2) union() >>> s1.union(s2) {1, 2, 3, 4, 5} >>> s1 | s2 {1, 2, 3, 4, 5} 3. intersect(s) Method: Returns an intersection of two sets.The \u2018&\u2019 operator comes can also be used in this case. intersection() >>> s1.intersection(s2) {3} >>> s1 & s2 {3} difference difference(s) Method: Returns a set containing all the elements of invoking set but not of the second set. We can use \u2018-\u2018 operator here. >>> s1.difference(s2) {1, 2} >>> s1 - s2 {1, 2} 5. clear() Method: Empties the whole set. >>> s1.clear() >>> s2.clear() >>> s1 set() >>> s2 set() discard() discard() Method: The discard() method takes a single element x and removes it from the set (if present). >>> s1 {1, 2, 3} >>> s1.discard(1) >>> s1 {2, 3} issubset() issubset() Method: The issubset() method returns True if all elements of a set are present in another set (passed as an argument). If not, it returns False. >>> s1 {1, 2, 3} >>> s1.issubset({1,2,3,4}) True Operators for Sets Sets and frozen sets support the following operators: >>> k = 1 >>> key in s1 # containment check True >>> key not in s1 # non-containment check False >>> s1 == s2 # s1 is equivalent to s2 False >>> s1 != s2 # s1 is not equivalent to s2 True >>> s1 <= s2 # s1 is subset of s2 False >>> s1 < s2 # s1 is proper subset of s2 False >>> s1 >= s2 # s1 is superset of s2 False >>> s1 > s2 # s1 is proper superset of s2 False >>> s1 | s2 # the union of s1 and s2 {1, 2, 3, 4, 5} >>> s1 & s2 # the intersection of s1 and s2 {3} >>> s1 - s2 # the set of elements in s1 but not s2 {1, 2} >>> s1 ^ s2 # the set of elements in precisely one of s1 or s2 {1, 2, 4, 5}","title":"Sets"},{"location":"python/useful/Sets/#sets","text":"Sets In Python A Set is an unordered collection data type that is iterable, mutable, and has no duplicate elements. Python\u2019s set class represents the mathematical notion of a set. The major advantage of using a set, as opposed to a list, is that it has a highly optimized method for checking whether a specific element is contained in the set. This is based on a data structure known as a hash table. Methods:","title":"Sets"},{"location":"python/useful/Sets/#add","text":"add(x) Method: Adds the item x to set if it is not already present in the set. >>> s3.add(9) >>> s3 {9, 3} 2. union(s) Method: Returns a union of two set.Using the \u2018|\u2019 operator between 2 sets is the same as writing set1.union(set2)","title":"add()"},{"location":"python/useful/Sets/#union","text":">>> s1.union(s2) {1, 2, 3, 4, 5} >>> s1 | s2 {1, 2, 3, 4, 5} 3. intersect(s) Method: Returns an intersection of two sets.The \u2018&\u2019 operator comes can also be used in this case.","title":"union()"},{"location":"python/useful/Sets/#intersection","text":">>> s1.intersection(s2) {3} >>> s1 & s2 {3}","title":"intersection()"},{"location":"python/useful/Sets/#difference","text":"difference(s) Method: Returns a set containing all the elements of invoking set but not of the second set. We can use \u2018-\u2018 operator here. >>> s1.difference(s2) {1, 2} >>> s1 - s2 {1, 2} 5. clear() Method: Empties the whole set. >>> s1.clear() >>> s2.clear() >>> s1 set() >>> s2 set()","title":"difference"},{"location":"python/useful/Sets/#discard","text":"discard() Method: The discard() method takes a single element x and removes it from the set (if present). >>> s1 {1, 2, 3} >>> s1.discard(1) >>> s1 {2, 3}","title":"discard()"},{"location":"python/useful/Sets/#issubset","text":"issubset() Method: The issubset() method returns True if all elements of a set are present in another set (passed as an argument). If not, it returns False. >>> s1 {1, 2, 3} >>> s1.issubset({1,2,3,4}) True Operators for Sets Sets and frozen sets support the following operators: >>> k = 1 >>> key in s1 # containment check True >>> key not in s1 # non-containment check False >>> s1 == s2 # s1 is equivalent to s2 False >>> s1 != s2 # s1 is not equivalent to s2 True >>> s1 <= s2 # s1 is subset of s2 False >>> s1 < s2 # s1 is proper subset of s2 False >>> s1 >= s2 # s1 is superset of s2 False >>> s1 > s2 # s1 is proper superset of s2 False >>> s1 | s2 # the union of s1 and s2 {1, 2, 3, 4, 5} >>> s1 & s2 # the intersection of s1 and s2 {3} >>> s1 - s2 # the set of elements in s1 but not s2 {1, 2} >>> s1 ^ s2 # the set of elements in precisely one of s1 or s2 {1, 2, 4, 5}","title":"issubset()"},{"location":"python/useful/Sorted/","text":"Sorted Sort Arrays Want to sort something, sorted() is a great start. Syntax: sorted(iterable, key, reverse) Parameters: sorted takes three parameters from which two are optional. Iterable: sequence (list, tuple, string) or collection (dictionary, set, frozenset) or any other iterator that needs to be sorted Key(optional) : A function that would server as a key or a basis of sort comparison Reverse(optional) : If set true, then the iterable would be sorted in reverse (descending) order, by default it is set as false Note: A list also has sort() method which performs the same way as sorted(). Only difference being, sort() method doesn't return any value and changes the original list itself. x = [2,44,3,87,5] print(x) # [2, 44, 3, 87, 5] print(sorted(x)) #[2, 3, 5, 44, 87] print(sorted(x, reverse=True)) # [87, 44, 5, 3, 2] Custom Sorting using the key parameter: sorted() function has an optional parameter called \u2018key\u2019 which takes a function as its value. This key function transforms each element before sorting, it takes the value and returns 1 value which is then used within sort instead of the original value. For example, if we pass a list of strings in sorted(), it gets sorted alphabetically . But if we specify key = len, i.e. give len function as key, then the strings would be passed to len, and the value it returns, i.e. the length of strings will be sorted. Which means that the strings would be sorted based on their lengths instead # sort by your own criteria L = [\"cccc\", \"b\", \"dd\", \"aaa\"] print(\"Normal sort :\", sorted(L)) print(\"Sort with len :\", sorted(L, key = len))","title":"sorted()"},{"location":"python/useful/Sorted/#sorted","text":"Sort Arrays Want to sort something, sorted() is a great start. Syntax: sorted(iterable, key, reverse) Parameters: sorted takes three parameters from which two are optional. Iterable: sequence (list, tuple, string) or collection (dictionary, set, frozenset) or any other iterator that needs to be sorted Key(optional) : A function that would server as a key or a basis of sort comparison Reverse(optional) : If set true, then the iterable would be sorted in reverse (descending) order, by default it is set as false Note: A list also has sort() method which performs the same way as sorted(). Only difference being, sort() method doesn't return any value and changes the original list itself. x = [2,44,3,87,5] print(x) # [2, 44, 3, 87, 5] print(sorted(x)) #[2, 3, 5, 44, 87] print(sorted(x, reverse=True)) # [87, 44, 5, 3, 2] Custom Sorting using the key parameter: sorted() function has an optional parameter called \u2018key\u2019 which takes a function as its value. This key function transforms each element before sorting, it takes the value and returns 1 value which is then used within sort instead of the original value. For example, if we pass a list of strings in sorted(), it gets sorted alphabetically . But if we specify key = len, i.e. give len function as key, then the strings would be passed to len, and the value it returns, i.e. the length of strings will be sorted. Which means that the strings would be sorted based on their lengths instead # sort by your own criteria L = [\"cccc\", \"b\", \"dd\", \"aaa\"] print(\"Normal sort :\", sorted(L)) print(\"Sort with len :\", sorted(L, key = len))","title":"Sorted"},{"location":"python/useful/Zip/","text":"Zip Combine iterables and return them as tuple sets. The zip() function returns an iterator of tuples based on the iterable object. If no parameters are passed, zip() returns an empty iterator If a single iterable is passed, zip() returns an iterator of 1-tuples. Meaning, the number of elements in each tuple is 1 If multiple iterables are passed, ith tuple contains ith iterable values from all iterables. Suppose, two iterables are passed; one iterable containing 3 and other containing 5 elements, then the returned iterator will have 3 tuples >>> zip() <zip object at 0x102c9be48> # length 0 >>> list(zip()) [] # length 1 >>> list(zip([1,2,3])) [(1,), (2,), (3,)] # same length iterables >>> x, y = [1,2,3], [4,5,6] >>> list(zip(x,y)) [(1, 4), (2, 5), (3, 6)] # different length iterables >>> x, y = [1,2,3], [4,5,6,7] >>> list(zip(x,y)) [(1, 4), (2, 5), (3, 6)] iterables - can be built-in iterables (like: list, set, tuple, string, dict...), or user-defined iterables (object that has iter method). x, y, z = [1,2,3], [4,5,6], {'a':4,'b':5,'c':6} # dictionaries use keys by default results_default = set(zip(x,y,z)) results_2 = set(zip(x,y,z.keys())) results_3 = set(zip(x,y,z.values())) print(results_default) # {(3, 6, 'c'), (1, 4, 'a'), (2, 5, 'b')} print(results_2) # {(3, 6, 'c'), (1, 4, 'a'), (2, 5, 'b')} print(results_3) # {(1, 4, 4), (3, 6, 6), (2, 5, 5)} View the zip contents with a list or set or tuple data type: >>> list(zip(x,y)) [(1, 4), (2, 5), (3, 6)] >>> set(zip(x,y)) {(2, 5), (3, 6), (1, 4)} >>> tuple(zip(x,y)) ((1, 4), (2, 5), (3, 6)) Unzipping is possible too: > x [1, 2, 3] >>> y [4, 5, 6, 7] >>> list(zip(x,y)) [(1, 4), (2, 5), (3, 6)] # Use * to unzip a zip object. You have to call zip() as a wrapper for *zip(). >>> list(zip(*zip(x,y))) [(1, 2, 3), (4, 5, 6)] >>> zip(*zip(x,y)) <zip object at 0x102ccb888> # The zip object is automatically unpacked into a nd b. >>> a,b = zip(*zip(x,y)) >>> a (1, 2, 3) >>> b (4, 5, 6) >>> Watch what happens when you try to view a zip object with a dictionary: >>> dict(zip([1,2],['a','b'])) {1: 'a', 2: 'b'} We can create dictionaries from individual unassociated key, values lists!","title":"zip()"},{"location":"python/useful/Zip/#zip","text":"Combine iterables and return them as tuple sets. The zip() function returns an iterator of tuples based on the iterable object. If no parameters are passed, zip() returns an empty iterator If a single iterable is passed, zip() returns an iterator of 1-tuples. Meaning, the number of elements in each tuple is 1 If multiple iterables are passed, ith tuple contains ith iterable values from all iterables. Suppose, two iterables are passed; one iterable containing 3 and other containing 5 elements, then the returned iterator will have 3 tuples >>> zip() <zip object at 0x102c9be48> # length 0 >>> list(zip()) [] # length 1 >>> list(zip([1,2,3])) [(1,), (2,), (3,)] # same length iterables >>> x, y = [1,2,3], [4,5,6] >>> list(zip(x,y)) [(1, 4), (2, 5), (3, 6)] # different length iterables >>> x, y = [1,2,3], [4,5,6,7] >>> list(zip(x,y)) [(1, 4), (2, 5), (3, 6)] iterables - can be built-in iterables (like: list, set, tuple, string, dict...), or user-defined iterables (object that has iter method). x, y, z = [1,2,3], [4,5,6], {'a':4,'b':5,'c':6} # dictionaries use keys by default results_default = set(zip(x,y,z)) results_2 = set(zip(x,y,z.keys())) results_3 = set(zip(x,y,z.values())) print(results_default) # {(3, 6, 'c'), (1, 4, 'a'), (2, 5, 'b')} print(results_2) # {(3, 6, 'c'), (1, 4, 'a'), (2, 5, 'b')} print(results_3) # {(1, 4, 4), (3, 6, 6), (2, 5, 5)} View the zip contents with a list or set or tuple data type: >>> list(zip(x,y)) [(1, 4), (2, 5), (3, 6)] >>> set(zip(x,y)) {(2, 5), (3, 6), (1, 4)} >>> tuple(zip(x,y)) ((1, 4), (2, 5), (3, 6)) Unzipping is possible too: > x [1, 2, 3] >>> y [4, 5, 6, 7] >>> list(zip(x,y)) [(1, 4), (2, 5), (3, 6)] # Use * to unzip a zip object. You have to call zip() as a wrapper for *zip(). >>> list(zip(*zip(x,y))) [(1, 2, 3), (4, 5, 6)] >>> zip(*zip(x,y)) <zip object at 0x102ccb888> # The zip object is automatically unpacked into a nd b. >>> a,b = zip(*zip(x,y)) >>> a (1, 2, 3) >>> b (4, 5, 6) >>> Watch what happens when you try to view a zip object with a dictionary: >>> dict(zip([1,2],['a','b'])) {1: 'a', 2: 'b'} We can create dictionaries from individual unassociated key, values lists!","title":"Zip"},{"location":"sql/postgres/Postgres/","text":"Postgres SELECT * FROM Something","title":"Postgres"},{"location":"sql/postgres/Postgres/#postgres","text":"SELECT * FROM Something","title":"Postgres"},{"location":"sql/sql_server/Sql Server/","text":"SQL Server Testing the addition of a new language SELECT TOP 10000 sum(colC) FROM DB_Server.dbo.DB_Table WHERE colA = 'some value' GROUP BY colB","title":"SQL server"},{"location":"sql/sql_server/Sql Server/#sql-server","text":"Testing the addition of a new language SELECT TOP 10000 sum(colC) FROM DB_Server.dbo.DB_Table WHERE colA = 'some value' GROUP BY colB","title":"SQL Server"},{"location":"sql/sqlite/Sqlite/","text":"Sqlite .tables The following notes are from sqlitetutorial.net List tables after connecting using .tables $ sqlite3 kaggle_rsna SQLite version 3.11.0 2016-02-15 17:29:24 Enter \".help\" for usage hints. sqlite> .tables all_images final_annotation_list all_images_corrected remove_exams annotations remove_series annotations_corrected study_and_instance_annotation_ids The .tables command also can be used to show temporary tables. See the following example: First, create a new temporary table named temp_table1: sqlite> CREATE TEMPORARY TABLE temp_table1( name TEXT ); Second, list all tables from the database: sqlite> .tables The following shows the output: albums employees invoices playlists artists genres media_types temp.temp_table1 customers invoice_items playlist_track tracks Because the schema of temporary tables is temp, the command showed the names of schema and table of the temporary table such as temp.temp_table1 . If you want to show tables with the specific name, you can add a matching pattern: .tables pattern The command works the same as LIKE operator. The pattern must be surrounded by single quotation marks ('). For example, to find tables whose names start with the letter \u2018a\u2019, you use the following command: sqlite> .table 'a%' Here is the output: albums artists To shows the tables whose name contains the string ck, you use the %ck% pattern as shown in the following command: sqlite> .tables '%ck%' The output is as follows: playlist_track tracks Showing tables using SQL statement: Another way to list all tables in a database is to query them from the sqlite_master table. SELECT name FROM sqlite_master WHERE type ='table' AND name NOT LIKE 'sqlite_%'; Here is the output: name albums customers employees genres invoices invoice_items media_types playlists playlist_track tracks .schema View the schema of a particular table: sqlite> .schema table sqlite> .schema all_images CREATE TABLE all_images( \"InstanceID\" TEXT, \"SeriesID\" TEXT, \"StudyID\" TEXT ); bulk insert If the table doesn't exist, sqlite will try to create it and it's scheme assuming a header. sqlite> .mode csv all_images sqlite> .import <path_to_csv> all_images","title":"sqlite"},{"location":"sql/sqlite/Sqlite/#sqlite","text":"","title":"Sqlite"},{"location":"sql/sqlite/Sqlite/#tables","text":"The following notes are from sqlitetutorial.net List tables after connecting using .tables $ sqlite3 kaggle_rsna SQLite version 3.11.0 2016-02-15 17:29:24 Enter \".help\" for usage hints. sqlite> .tables all_images final_annotation_list all_images_corrected remove_exams annotations remove_series annotations_corrected study_and_instance_annotation_ids The .tables command also can be used to show temporary tables. See the following example: First, create a new temporary table named temp_table1: sqlite> CREATE TEMPORARY TABLE temp_table1( name TEXT ); Second, list all tables from the database: sqlite> .tables The following shows the output: albums employees invoices playlists artists genres media_types temp.temp_table1 customers invoice_items playlist_track tracks Because the schema of temporary tables is temp, the command showed the names of schema and table of the temporary table such as temp.temp_table1 . If you want to show tables with the specific name, you can add a matching pattern: .tables pattern The command works the same as LIKE operator. The pattern must be surrounded by single quotation marks ('). For example, to find tables whose names start with the letter \u2018a\u2019, you use the following command: sqlite> .table 'a%' Here is the output: albums artists To shows the tables whose name contains the string ck, you use the %ck% pattern as shown in the following command: sqlite> .tables '%ck%' The output is as follows: playlist_track tracks Showing tables using SQL statement: Another way to list all tables in a database is to query them from the sqlite_master table. SELECT name FROM sqlite_master WHERE type ='table' AND name NOT LIKE 'sqlite_%'; Here is the output: name albums customers employees genres invoices invoice_items media_types playlists playlist_track tracks","title":".tables"},{"location":"sql/sqlite/Sqlite/#schema","text":"View the schema of a particular table: sqlite> .schema table sqlite> .schema all_images CREATE TABLE all_images( \"InstanceID\" TEXT, \"SeriesID\" TEXT, \"StudyID\" TEXT );","title":".schema"},{"location":"sql/sqlite/Sqlite/#bulk-insert","text":"If the table doesn't exist, sqlite will try to create it and it's scheme assuming a header. sqlite> .mode csv all_images sqlite> .import <path_to_csv> all_images","title":"bulk insert"}]}