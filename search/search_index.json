{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Ben's Code Journal May it aid you in your coding adventures if a google search lands you here. mkdocs links","title":"Home"},{"location":"#welcome-to-bens-code-journal","text":"May it aid you in your coding adventures if a google search lands you here. mkdocs links","title":"Welcome to Ben's Code Journal"},{"location":"about/","text":"About Obscura ipsa veteris augebat vias Lorem markdownum in sucis amore fuerat: cum simul adnuit. Vigor levat, aurigenae regis longo, annos ver gerit. Ab Troiam tertius nonne, si arma; novi ille flatuque aures crus fugit aperit sed. jsonWpaDefragment += language_clean - yottabyte_memory.ics(laser * 35, dropBank, megabyteTypeface); memorySoftwareTiff = drive_visual_unix; infringement = dlc.hashtag_frequency_link(-5, cache); var scareware_desktop = cpmBinPowerpoint( cookie_windows.keystroke_torrent_page(wpa, flowchartParityFile) - 78); Illum et equos longa fictus dixit Coniuge et quoque neve, vices et eripitur excidit cernis longa solis tibi! Quae tympana abeunt exhalantes est pictae carinas seque remanente placere filia, sinat, exceptas. Tam loco quis quoque timeri pallor deperderet pavefacta haud responsa? Vocat abest habet terram attonitas nobis turba referebat utrique aliisque enim formaeque contingere omnes. Mero intervenit magno: nomen quo liquores nec, e trahentem. megabyte -= cableShiftPublic.market(sdOpenOnly.mebibyteFolder( service_terabyte_registry, ddr, mp_vpi_bus), memoryWirelessArt * modeServerCrossplatform); icfFileAnd = refreshTutorialPup; sipPowerRw(2 - 4, of); wamp_ppc_topology = wordNntpPack; Dedisset tantus ora di tectis arcumque vario Et iussa me quicquam se Dauno mediis daulida. Qui auras habet sua confessaque, resurgebant innumerae messes quidem cui calcitrat ut ducit ! Dominae sistetur cohibentem blanditiis labuntur medullis flammas; spectavit finemque unus; nymphe infelix quoque, delubraque causa: hic. Hoc quod decus quaque iactata rerum premis blandas in tertia fixa delphines liquido gemini peragebant veniet aequor cursus fieri. Est cernit Amphrysi in moenia tum certamine Parsque conplexae salices hoc Hac habes videre lumina transmittere illic lambentem Visa famulae Planxitque magno proles levatus legendo cavernis tympana: et et igitur ut unda et gaudent? Iuventus crevit in me medicas dextra peperisse trepidantum nullo vulneribus Parnasos mentisque numero in . Solet cernis maiores media moles haec alios addunt quaque, tingui.","title":"About"},{"location":"about/#about","text":"","title":"About"},{"location":"about/#obscura-ipsa-veteris-augebat-vias","text":"Lorem markdownum in sucis amore fuerat: cum simul adnuit. Vigor levat, aurigenae regis longo, annos ver gerit. Ab Troiam tertius nonne, si arma; novi ille flatuque aures crus fugit aperit sed. jsonWpaDefragment += language_clean - yottabyte_memory.ics(laser * 35, dropBank, megabyteTypeface); memorySoftwareTiff = drive_visual_unix; infringement = dlc.hashtag_frequency_link(-5, cache); var scareware_desktop = cpmBinPowerpoint( cookie_windows.keystroke_torrent_page(wpa, flowchartParityFile) - 78);","title":"Obscura ipsa veteris augebat vias"},{"location":"about/#illum-et-equos-longa-fictus-dixit","text":"Coniuge et quoque neve, vices et eripitur excidit cernis longa solis tibi! Quae tympana abeunt exhalantes est pictae carinas seque remanente placere filia, sinat, exceptas. Tam loco quis quoque timeri pallor deperderet pavefacta haud responsa? Vocat abest habet terram attonitas nobis turba referebat utrique aliisque enim formaeque contingere omnes. Mero intervenit magno: nomen quo liquores nec, e trahentem. megabyte -= cableShiftPublic.market(sdOpenOnly.mebibyteFolder( service_terabyte_registry, ddr, mp_vpi_bus), memoryWirelessArt * modeServerCrossplatform); icfFileAnd = refreshTutorialPup; sipPowerRw(2 - 4, of); wamp_ppc_topology = wordNntpPack;","title":"Illum et equos longa fictus dixit"},{"location":"about/#dedisset-tantus-ora-di-tectis-arcumque-vario","text":"Et iussa me quicquam se Dauno mediis daulida. Qui auras habet sua confessaque, resurgebant innumerae messes quidem cui calcitrat ut ducit ! Dominae sistetur cohibentem blanditiis labuntur medullis flammas; spectavit finemque unus; nymphe infelix quoque, delubraque causa: hic. Hoc quod decus quaque iactata rerum premis blandas in tertia fixa delphines liquido gemini peragebant veniet aequor cursus fieri. Est cernit Amphrysi in moenia tum certamine Parsque conplexae salices hoc Hac habes videre lumina transmittere illic lambentem Visa famulae Planxitque magno proles levatus legendo cavernis tympana: et et igitur ut unda et gaudent? Iuventus crevit in me medicas dextra peperisse trepidantum nullo vulneribus Parnasos mentisque numero in . Solet cernis maiores media moles haec alios addunt quaque, tingui.","title":"Dedisset tantus ora di tectis arcumque vario"},{"location":"javascript/javascript/","text":"Javascript Obscura ipsa veteris augebat vias Lorem markdownum in sucis amore fuerat: cum simul adnuit. Vigor levat, aurigenae regis longo, annos ver gerit. Ab Troiam tertius nonne, si arma; novi ille flatuque aures crus fugit aperit sed. jsonWpaDefragment += language_clean - yottabyte_memory.ics(laser * 35, dropBank, megabyteTypeface); memorySoftwareTiff = drive_visual_unix; infringement = dlc.hashtag_frequency_link(-5, cache); var scareware_desktop = cpmBinPowerpoint( cookie_windows.keystroke_torrent_page(wpa, flowchartParityFile) - 78); Illum et equos longa fictus dixit Coniuge et quoque neve, vices et eripitur excidit cernis longa solis tibi! Quae tympana abeunt exhalantes est pictae carinas seque remanente placere filia, sinat, exceptas. Tam loco quis quoque timeri pallor deperderet pavefacta haud responsa? Vocat abest habet terram attonitas nobis turba referebat utrique aliisque enim formaeque contingere omnes. Mero intervenit magno: nomen quo liquores nec, e trahentem. megabyte -= cableShiftPublic.market(sdOpenOnly.mebibyteFolder( service_terabyte_registry, ddr, mp_vpi_bus), memoryWirelessArt * modeServerCrossplatform); icfFileAnd = refreshTutorialPup; sipPowerRw(2 - 4, of); wamp_ppc_topology = wordNntpPack; Dedisset tantus ora di tectis arcumque vario Et iussa me quicquam se Dauno mediis daulida. Qui auras habet sua confessaque, resurgebant innumerae messes quidem cui calcitrat ut ducit ! Dominae sistetur cohibentem blanditiis labuntur medullis flammas; spectavit finemque unus; nymphe infelix quoque, delubraque causa: hic. Hoc quod decus quaque iactata rerum premis blandas in tertia fixa delphines liquido gemini peragebant veniet aequor cursus fieri. Est cernit Amphrysi in moenia tum certamine Parsque conplexae salices hoc Hac habes videre lumina transmittere illic lambentem Visa famulae Planxitque magno proles levatus legendo cavernis tympana: et et igitur ut unda et gaudent? Iuventus crevit in me medicas dextra peperisse trepidantum nullo vulneribus Parnasos mentisque numero in . Solet cernis maiores media moles haec alios addunt quaque, tingui.","title":"Javascript"},{"location":"javascript/javascript/#javascript","text":"","title":"Javascript"},{"location":"javascript/javascript/#obscura-ipsa-veteris-augebat-vias","text":"Lorem markdownum in sucis amore fuerat: cum simul adnuit. Vigor levat, aurigenae regis longo, annos ver gerit. Ab Troiam tertius nonne, si arma; novi ille flatuque aures crus fugit aperit sed. jsonWpaDefragment += language_clean - yottabyte_memory.ics(laser * 35, dropBank, megabyteTypeface); memorySoftwareTiff = drive_visual_unix; infringement = dlc.hashtag_frequency_link(-5, cache); var scareware_desktop = cpmBinPowerpoint( cookie_windows.keystroke_torrent_page(wpa, flowchartParityFile) - 78);","title":"Obscura ipsa veteris augebat vias"},{"location":"javascript/javascript/#illum-et-equos-longa-fictus-dixit","text":"Coniuge et quoque neve, vices et eripitur excidit cernis longa solis tibi! Quae tympana abeunt exhalantes est pictae carinas seque remanente placere filia, sinat, exceptas. Tam loco quis quoque timeri pallor deperderet pavefacta haud responsa? Vocat abest habet terram attonitas nobis turba referebat utrique aliisque enim formaeque contingere omnes. Mero intervenit magno: nomen quo liquores nec, e trahentem. megabyte -= cableShiftPublic.market(sdOpenOnly.mebibyteFolder( service_terabyte_registry, ddr, mp_vpi_bus), memoryWirelessArt * modeServerCrossplatform); icfFileAnd = refreshTutorialPup; sipPowerRw(2 - 4, of); wamp_ppc_topology = wordNntpPack;","title":"Illum et equos longa fictus dixit"},{"location":"javascript/javascript/#dedisset-tantus-ora-di-tectis-arcumque-vario","text":"Et iussa me quicquam se Dauno mediis daulida. Qui auras habet sua confessaque, resurgebant innumerae messes quidem cui calcitrat ut ducit ! Dominae sistetur cohibentem blanditiis labuntur medullis flammas; spectavit finemque unus; nymphe infelix quoque, delubraque causa: hic. Hoc quod decus quaque iactata rerum premis blandas in tertia fixa delphines liquido gemini peragebant veniet aequor cursus fieri. Est cernit Amphrysi in moenia tum certamine Parsque conplexae salices hoc Hac habes videre lumina transmittere illic lambentem Visa famulae Planxitque magno proles levatus legendo cavernis tympana: et et igitur ut unda et gaudent? Iuventus crevit in me medicas dextra peperisse trepidantum nullo vulneribus Parnasos mentisque numero in . Solet cernis maiores media moles haec alios addunt quaque, tingui.","title":"Dedisset tantus ora di tectis arcumque vario"},{"location":"mkdocs_notes/quick_notes/","text":"Deploy the server\\site Be sure you are in ./code-journal/ or ./<project root> code-journal |-docs |-site |-mkdocs.yml Benjamins-MBP-2:code-journal bbearce$ pwd /Users/bbearce/Documents/Code/code-journal Use this code to serve the developer site $ mkdocs serve Use this code to build the site $ mkdocs build To push to github do this: cd ../bbearce.github.io/ mkdocs gh-deploy --config-file ../code-journal/mkdocs.yml --remote-branch master Detailed Github Notes github deploy","title":"Deploy the server\\site"},{"location":"mkdocs_notes/quick_notes/#deploy-the-serversite","text":"Be sure you are in ./code-journal/ or ./<project root> code-journal |-docs |-site |-mkdocs.yml Benjamins-MBP-2:code-journal bbearce$ pwd /Users/bbearce/Documents/Code/code-journal Use this code to serve the developer site $ mkdocs serve Use this code to build the site $ mkdocs build To push to github do this: cd ../bbearce.github.io/ mkdocs gh-deploy --config-file ../code-journal/mkdocs.yml --remote-branch master","title":"Deploy the server\\site"},{"location":"mkdocs_notes/quick_notes/#detailed-github-notes","text":"github deploy","title":"Detailed Github Notes"},{"location":"python/advanced/classes/","text":"Basic Class Definition Intro: - Class: Blueprint - Object - Instance class Shark: # Basic Method definition def swim(self): print(\"The shark is swimming.\") def be_awesome(self): print(\"The shark is being awesome.\") Notice the use of self to reference an instance specifically...the one calling the method. Implementing sammy = Shark() sammy.swim() # >>> The shark is swimming. sammy.be_awesome() # >>> The shark is being awesome. Now let's dicuss init . class Shark: def __init__(self): print(\"This is the constructor method.\") >>> Shark() This is the constructor method. <__main__.Shark object at 0x10348d470> Finally, we can set the name of the Shark object sammy as equal to \"Sammy\" by passing it as a parameter of the Shark class: class Shark: def __init__(self, name): self.name = name def swim(self): print(self.name + \" is swimming.\") def be_awesome(self): print(self.name + \" is being awesome.\") def main(): # Set name of Shark object sammy = Shark(\"Sammy\") sammy.swim() sammy.be_awesome() if __name__ == \"__main__\": main() run... $ python shark.py Sammy is swimming. Sammy is being awesome. Inheritance super() and inheritance. In this tutorial, you\u2019ll learn about the following: The concept of inheritance in Python Multiple inheritance in Python How the super() function works How the super() function in single inheritance works How the super() function in multiple inheritance works Let's start with a simple example: class Rectangle: def __init__(self, length, width): self.length = length self.width = width def area(self): return self.length * self.width def perimeter(self): return 2 * self.length + 2 * self.width class Square: def __init__(self, length): self.length = length def area(self): return self.length * self.length def perimeter(self): return 4 * self.length >>> square = Square(4) >>> square.area() 16 >>> rectangle = Rectangle(2,4) >>> rectangle.area() 8 Here no references to inheritance are being made. super() in Single Inheritance super() gives you access to methods in a superclass from the subclass that inherits from it. super() alone returns a temporary object of the superclass that then allows you to call that superclass\u2019s methods. By using inheritance, you can reduce the amount of code you write while simultaneously reflecting the real-world relationship between rectangles and squares: class Rectangle: def __init__(self, length, width): self.length = length self.width = width def area(self): return self.length * self.width def perimeter(self): return 2 * self.length + 2 * self.width # Here we declare that the Square class inherits from the Rectangle class class Square(Rectangle): def __init__(self, length): super().__init__(length, length) >>> square = Square(4) >>> square.area() 16 What Can super() Do for You? Like in other object-oriented languages, it allows you to call methods of the superclass in your subclass. The primary use case of this is to extend the functionality of the inherited method. In the example below, you will create a class Cube that inherits from Square and extends the functionality of .area() (inherited from the Rectangle class through Square) to calculate the surface area and volume of a Cube instance: class Square(Rectangle): def __init__(self, length): super().__init__(length, length) class Cube(Square): def surface_area(self): face_area = super().area() return face_area * 6 def volume(self): face_area = super().area() return face_area * self.length >>> cube = Cube(3) >>> cube.surface_area() 54 >>> cube.volume() 27 Here you have implemented two methods for the Cube class: .surface_area() and .volume(). Both of these calculations rely on calculating the area of a single face, so rather than reimplementing the area calculation, you use super() to extend the area calculation. Also notice that the Cube class definition does not have an . init (). Because Cube inherits from Square and . init () doesn\u2019t really do anything differently for Cube than it already does for Square, you can skip defining it, and the . init () of the superclass (Square) will be called automatically. A super() Deep Dive While the examples above (and below) call super() without any parameters, super() can also take two parameters: the first is the subclass, and the second parameter is an object that is an instance of that subclass. First, let\u2019s see two examples showing what manipulating the first variable can do, using the classes already shown: class Rectangle: def __init__(self, length, width): self.length = length self.width = width def area(self): return self.length * self.width def perimeter(self): return 2 * self.length + 2 * self.width class Square(Rectangle): def __init__(self, length): super(Square, self).__init__(length, length) In Python 3, the super(Square, self) call is equivalent to the parameterless super() call. The first parameter refers to the subclass Square, while the second parameter refers to a Square object which, in this case, is self. You can call super() with other classes as well: class Cube(Square): def surface_area(self): face_area = super(Square, self).area() return face_area * 6 def volume(self): face_area = super(Square, self).area() return face_area * self.length In this example, you are setting Square as the subclass argument to super(), instead of Cube. This causes super() to start searching for a matching method (in this case, .area()) at one level above Square in the instance hierarchy, in this case Rectangle. In this specific example, the behavior doesn\u2019t change. But imagine that Square also implemented an .area() function that you wanted to make sure Cube did not use. Calling super() in this way allows you to do that. What about the second parameter? Remember, this is an object that is an instance of the class used as the first parameter. For an example, isinstance(Cube, Square) must return True. By including an instantiated object, super() returns a bound method: a method that is bound to the object, which gives the method the object\u2019s context such as any instance attributes. If this parameter is not included, the method returned is just a function, unassociated with an object\u2019s context. For more information about bound methods, unbound methods, and functions, read the Python documentation on its descriptor system . Multiple Inheritance and Composition super() in Multiple Inheritance Now that you\u2019ve worked through an overview and some examples of super() and single inheritance, you will be introduced to an overview and some examples that will demonstrate how multiple inheritance works and how super() enables that functionality. Multiple Inheritance Overview There is another use case in which super() really shines, and this one isn\u2019t as common as the single inheritance scenario. In addition to single inheritance, Python supports multiple inheritance, in which a subclass can inherit from multiple superclasses that don\u2019t necessarily inherit from each other (also known as sibling classes). Superclass 1 Superclass 2 | | | | | | | | | | ------> Subclass <------- Let's get reacquainted with our base code: class Rectangle: def __init__(self, length, width): self.length = length self.width = width def area(self): return self.length * self.width def perimeter(self): return 2 * self.length + 2 * self.width class Square(Rectangle): def __init__(self, length): super(Square, self).__init__(length, length) Now let's proceed... To better illustrate multiple inheritance in action, here is some code for you to try out, showing how you can build a right pyramid (a pyramid with a square base) out of a Triangle and a Square: class Triangle: def __init__(self, base, height): self.base = base self.height = height def area(self): return 0.5 * self.base * self.height class RightPyramid(Triangle, Square): def __init__(self, base, slant_height): self.base = base self.slant_height = slant_height def area(self): base_area = super().area() perimeter = super().perimeter() return 0.5 * perimeter * self.slant_height + base_area This example declares a Triangle class and a RightPyramid class that inherits from both Square and Triangle. You\u2019ll see another .area() method that uses super() just like in single inheritance, with the aim of it reaching the .perimeter() and .area() methods defined all the way up in the Rectangle class. The problem, though, is that both superclasses (Triangle and Square) define a .area(). Take a second and think about what might happen when you call .area() on RightPyramid, and then try calling it like below: >> pyramid = RightPyramid(2, 4) >> pyramid.area() Traceback (most recent call last): File \"shapes.py\", line 63, in print(pyramid.area()) File \"shapes.py\", line 47, in area base_area = super().area() File \"shapes.py\", line 38, in area return 0.5 * self.base * self.height AttributeError: 'RightPyramid' object has no attribute 'height' Did you guess that Python will try to call Triangle.area()? This is because of something called the method resolution order. Method Resolution Order The method resolution order (or MRO) tells Python how to search for inherited methods. This comes in handy when you\u2019re using super() because the MRO tells you exactly where Python will look for a method you\u2019re calling with super() and in what order. Every class has an . mro attribute that allows us to inspect the order, so let\u2019s do that: >>> RightPyramid.__mro__ (<class '__main__.RightPyramid'>, <class '__main__.Triangle'>, <class '__main__.Square'>, <class '__main__.Rectangle'>, <class 'object'>) This tells us that methods will be searched first in Rightpyramid, then in Triangle, then in Square, then Rectangle, and then, if nothing is found, in object, from which all classes originate. The problem here is that the interpreter is searching for .area() in Triangle before Square and Rectangle, and upon finding .area() in Triangle, Python calls it instead of the one you want. Because Triangle.area() expects there to be a .height and a .base attribute, Python throws an AttributeError. The problem here is that the interpreter is searching for .area() in Triangle before Square and Rectangle, and upon finding .area() in Triangle, Python calls it instead of the one you want. Because Triangle.area() expects there to be a .height and a .base attribute, Python throws an AttributeError. Luckily, you have some control over how the MRO is constructed. Just by changing the signature of the RightPyramid class, you can search in the order you want, and the methods will resolve correctly: class RightPyramid(Square, Triangle): def __init__(self, base, slant_height): self.base = base self.slant_height = slant_height super().__init__(self.base) def area(self): base_area = super().area() perimeter = super().perimeter() return 0.5 * perimeter * self.slant_height + base_area Notice that RightPyramid initializes partially with the . init () from the Square class. This allows .area() to use the .length on the object, as is designed. Now, you can build a pyramid, inspect the MRO, and calculate the surface area: >>> pyramid = RightPyramid(2, 4) >>> RightPyramid.__mro__ (<class '__main__.RightPyramid'>, <class '__main__.Square'>, <class '__main__.Rectangle'>, <class '__main__.Triangle'>, <class 'object'>) >>> pyramid.area() 20.0 You see that the MRO is now what you\u2019d expect, and you can inspect the area of the pyramid as well, thanks to .area() and .perimeter(). There\u2019s still a problem here, though. For the sake of simplicity, I did a few things wrong in this example: the first, and arguably most importantly, was that I had two separate classes with the same method name and signature. This causes issues with method resolution, because the first instance of .area() that is encountered in the MRO list will be called. When you\u2019re using super() with multiple inheritance, it\u2019s imperative to design your classes to cooperate. Part of this is ensuring that your methods are unique so that they get resolved in the MRO, by making sure method signatures are unique\u2014whether by using method names or method parameters. In this case, to avoid a complete overhaul of your code, you can rename the Triangle class\u2019s .area() method to .tri_area(). This way, the area methods can continue using class properties rather than taking external parameters: class Triangle: def __init__(self, base, height): self.base = base self.height = height super().__init__() def tri_area(self): return 0.5 * self.base * self.height Let\u2019s also go ahead and use this in the RightPyramid class: class RightPyramid(Square, Triangle): def __init__(self, base, slant_height): self.base = base self.slant_height = slant_height super().__init__(self.base) def area(self): base_area = super().area() perimeter = super().perimeter() return 0.5 * perimeter * self.slant_height + base_area def area_2(self): base_area = super().area() triangle_area = super().tri_area() return triangle_area * 4 + base_area The next issue here is that the code doesn\u2019t have a delegated Triangle object like it does for a Square object, so calling .area_2() will give us an AttributeError since .base and .height don\u2019t have any values. You need to do two things to fix this: All methods that are called with super() need to have a call to their superclass\u2019s version of that method. This means that you will need to add super(). init () to the . init () methods of Triangle and Rectangle. Redesign all the . init () calls to take a keyword dictionary. See the complete code below. class Rectangle: def __init__(self, length, width, **kwargs): self.length = length self.width = width super().__init__(**kwargs) def area(self): return self.length * self.width def perimeter(self): return 2 * self.length + 2 * self.width # Here we declare that the Square class inherits from # the Rectangle class class Square(Rectangle): def __init__(self, length, **kwargs): super().__init__(length=length, width=length, **kwargs) class Cube(Square): def surface_area(self): face_area = super().area() return face_area * 6 def volume(self): face_area = super().area() return face_area * self.length class Triangle: def __init__(self, base, height, **kwargs): self.base = base self.height = height super().__init__(**kwargs) def tri_area(self): return 0.5 * self.base * self.height class RightPyramid(Square, Triangle): def __init__(self, base, slant_height, **kwargs): self.base = base self.slant_height = slant_height kwargs[\"height\"] = slant_height kwargs[\"length\"] = base super().__init__(base=base, **kwargs) def area(self): base_area = super().area() perimeter = super().perimeter() return 0.5 * perimeter * self.slant_height + base_area def area_2(self): base_area = super().area() triangle_area = super().tri_area() return triangle_area * 4 + base_area There are a number of important differences in this code: kwargs is modified in some places (such as RightPyramid. init ()): This will allow users of these objects to instantiate them only with the arguments that make sense for that particular object. Setting up named arguments before kwargs: You can see this in RightPyramid. init (). This has the neat effect of popping that key right out of the kwargs dictionary, so that by the time that it ends up at the end of the MRO in the object class, **kwargs is empty. Now, when you use these updated classes, you have this: >>> pyramid = RightPyramid(base=2, slant_height=4) >>> pyramid.area() 20.0 >>> pyramid.area_2() 20.0 It works! You\u2019ve used super() to successfully navigate a complicated class hierarchy while using both inheritance and composition to create new classes with minimal reimplementation. Quiz!!! When Rectangle calls super() what are the values of kwargs and what class gets it's init method called Answer: kwargs is still containing {'base': 2, 'height': 4} values as they haven't been removed from kwargs super().__init__(**kwargs) calls Triangle's init , but Rectangle doesn't inherit from Triangle so why? Remember the MRO? Let's look at RightPyramid's MRO >>> RightPyramid.__mro__ (<class '__main__.RightPyramid'>, <class '__main__.Square'>, <class '__main__.Rectangle'>, <class '__main__.Triangle'>, <class 'object'>) Even though Rectangle doesn't inherit from Triangle, Triangle is next in the list of classes to search for an init method. You'll notice object is at the end of the list. super().__init__(**kwargs) Multiple Inheritance Alternatives As you can see, multiple inheritance can be useful but also lead to very complicated situations and code that is hard to read. It\u2019s also rare to have objects that neatly inherit everything from more than multiple other objects. If you see yourself beginning to use multiple inheritance and a complicated class hierarchy, it\u2019s worth asking yourself if you can achieve code that is cleaner and easier to understand by using composition instead of inheritance. With composition, you can add very specific functionality to your classes from a specialized, simple class called a mixin. Since this article is focused on inheritance, I won\u2019t go into too much detail on composition and how to wield it in Python, but here\u2019s a short example using VolumeMixin to give specific functionality to our 3D objects\u2014in this case, a volume calculation: class Rectangle: def __init__(self, length, width): self.length = length self.width = width def area(self): return self.length * self.width class Square(Rectangle): def __init__(self, length): super().__init__(length, length) class VolumeMixin: def volume(self): return self.area() * self.height class Cube(VolumeMixin, Square): def __init__(self, length): super().__init__(length) self.height = length def face_area(self): return super().area() def surface_area(self): return super().area() * 6 In this example, the code was reworked to include a mixin called VolumeMixin. The mixin is then used by Cube and gives Cube the ability to calculate its volume, which is shown below: >>> cube = Cube(2) >>> cube.surface_area() 24 >>> cube.volume() 8 A super() Recap In this tutorial, you learned how to supercharge your classes with super(). Your journey started with a review of single inheritance and then showed how to call superclass methods easily with super(). You then learned how multiple inheritance works in Python, and techniques to combine super() with multiple inheritance. You also learned about how Python resolves method calls using the method resolution order (MRO), as well as how to inspect and modify the MRO to ensure appropriate methods are called at appropriate times. For more information about object-oriented programming in Python and using super(), check out these resources: Official super() documentation Python\u2019s super() Considered Super by Raymond Hettinger Object-Oriented Programming in Python 3","title":"Classes"},{"location":"python/advanced/classes/#basic-class-definition","text":"Intro: - Class: Blueprint - Object - Instance class Shark: # Basic Method definition def swim(self): print(\"The shark is swimming.\") def be_awesome(self): print(\"The shark is being awesome.\") Notice the use of self to reference an instance specifically...the one calling the method. Implementing sammy = Shark() sammy.swim() # >>> The shark is swimming. sammy.be_awesome() # >>> The shark is being awesome. Now let's dicuss init . class Shark: def __init__(self): print(\"This is the constructor method.\") >>> Shark() This is the constructor method. <__main__.Shark object at 0x10348d470> Finally, we can set the name of the Shark object sammy as equal to \"Sammy\" by passing it as a parameter of the Shark class: class Shark: def __init__(self, name): self.name = name def swim(self): print(self.name + \" is swimming.\") def be_awesome(self): print(self.name + \" is being awesome.\") def main(): # Set name of Shark object sammy = Shark(\"Sammy\") sammy.swim() sammy.be_awesome() if __name__ == \"__main__\": main() run... $ python shark.py Sammy is swimming. Sammy is being awesome.","title":"Basic Class Definition"},{"location":"python/advanced/classes/#inheritance","text":"super() and inheritance. In this tutorial, you\u2019ll learn about the following: The concept of inheritance in Python Multiple inheritance in Python How the super() function works How the super() function in single inheritance works How the super() function in multiple inheritance works Let's start with a simple example: class Rectangle: def __init__(self, length, width): self.length = length self.width = width def area(self): return self.length * self.width def perimeter(self): return 2 * self.length + 2 * self.width class Square: def __init__(self, length): self.length = length def area(self): return self.length * self.length def perimeter(self): return 4 * self.length >>> square = Square(4) >>> square.area() 16 >>> rectangle = Rectangle(2,4) >>> rectangle.area() 8 Here no references to inheritance are being made. super() in Single Inheritance super() gives you access to methods in a superclass from the subclass that inherits from it. super() alone returns a temporary object of the superclass that then allows you to call that superclass\u2019s methods. By using inheritance, you can reduce the amount of code you write while simultaneously reflecting the real-world relationship between rectangles and squares: class Rectangle: def __init__(self, length, width): self.length = length self.width = width def area(self): return self.length * self.width def perimeter(self): return 2 * self.length + 2 * self.width # Here we declare that the Square class inherits from the Rectangle class class Square(Rectangle): def __init__(self, length): super().__init__(length, length) >>> square = Square(4) >>> square.area() 16 What Can super() Do for You? Like in other object-oriented languages, it allows you to call methods of the superclass in your subclass. The primary use case of this is to extend the functionality of the inherited method. In the example below, you will create a class Cube that inherits from Square and extends the functionality of .area() (inherited from the Rectangle class through Square) to calculate the surface area and volume of a Cube instance: class Square(Rectangle): def __init__(self, length): super().__init__(length, length) class Cube(Square): def surface_area(self): face_area = super().area() return face_area * 6 def volume(self): face_area = super().area() return face_area * self.length >>> cube = Cube(3) >>> cube.surface_area() 54 >>> cube.volume() 27 Here you have implemented two methods for the Cube class: .surface_area() and .volume(). Both of these calculations rely on calculating the area of a single face, so rather than reimplementing the area calculation, you use super() to extend the area calculation. Also notice that the Cube class definition does not have an . init (). Because Cube inherits from Square and . init () doesn\u2019t really do anything differently for Cube than it already does for Square, you can skip defining it, and the . init () of the superclass (Square) will be called automatically. A super() Deep Dive While the examples above (and below) call super() without any parameters, super() can also take two parameters: the first is the subclass, and the second parameter is an object that is an instance of that subclass. First, let\u2019s see two examples showing what manipulating the first variable can do, using the classes already shown: class Rectangle: def __init__(self, length, width): self.length = length self.width = width def area(self): return self.length * self.width def perimeter(self): return 2 * self.length + 2 * self.width class Square(Rectangle): def __init__(self, length): super(Square, self).__init__(length, length) In Python 3, the super(Square, self) call is equivalent to the parameterless super() call. The first parameter refers to the subclass Square, while the second parameter refers to a Square object which, in this case, is self. You can call super() with other classes as well: class Cube(Square): def surface_area(self): face_area = super(Square, self).area() return face_area * 6 def volume(self): face_area = super(Square, self).area() return face_area * self.length In this example, you are setting Square as the subclass argument to super(), instead of Cube. This causes super() to start searching for a matching method (in this case, .area()) at one level above Square in the instance hierarchy, in this case Rectangle. In this specific example, the behavior doesn\u2019t change. But imagine that Square also implemented an .area() function that you wanted to make sure Cube did not use. Calling super() in this way allows you to do that. What about the second parameter? Remember, this is an object that is an instance of the class used as the first parameter. For an example, isinstance(Cube, Square) must return True. By including an instantiated object, super() returns a bound method: a method that is bound to the object, which gives the method the object\u2019s context such as any instance attributes. If this parameter is not included, the method returned is just a function, unassociated with an object\u2019s context. For more information about bound methods, unbound methods, and functions, read the Python documentation on its descriptor system .","title":"Inheritance"},{"location":"python/advanced/classes/#multiple-inheritance-and-composition","text":"super() in Multiple Inheritance Now that you\u2019ve worked through an overview and some examples of super() and single inheritance, you will be introduced to an overview and some examples that will demonstrate how multiple inheritance works and how super() enables that functionality. Multiple Inheritance Overview There is another use case in which super() really shines, and this one isn\u2019t as common as the single inheritance scenario. In addition to single inheritance, Python supports multiple inheritance, in which a subclass can inherit from multiple superclasses that don\u2019t necessarily inherit from each other (also known as sibling classes). Superclass 1 Superclass 2 | | | | | | | | | | ------> Subclass <------- Let's get reacquainted with our base code: class Rectangle: def __init__(self, length, width): self.length = length self.width = width def area(self): return self.length * self.width def perimeter(self): return 2 * self.length + 2 * self.width class Square(Rectangle): def __init__(self, length): super(Square, self).__init__(length, length) Now let's proceed... To better illustrate multiple inheritance in action, here is some code for you to try out, showing how you can build a right pyramid (a pyramid with a square base) out of a Triangle and a Square: class Triangle: def __init__(self, base, height): self.base = base self.height = height def area(self): return 0.5 * self.base * self.height class RightPyramid(Triangle, Square): def __init__(self, base, slant_height): self.base = base self.slant_height = slant_height def area(self): base_area = super().area() perimeter = super().perimeter() return 0.5 * perimeter * self.slant_height + base_area This example declares a Triangle class and a RightPyramid class that inherits from both Square and Triangle. You\u2019ll see another .area() method that uses super() just like in single inheritance, with the aim of it reaching the .perimeter() and .area() methods defined all the way up in the Rectangle class. The problem, though, is that both superclasses (Triangle and Square) define a .area(). Take a second and think about what might happen when you call .area() on RightPyramid, and then try calling it like below: >> pyramid = RightPyramid(2, 4) >> pyramid.area() Traceback (most recent call last): File \"shapes.py\", line 63, in print(pyramid.area()) File \"shapes.py\", line 47, in area base_area = super().area() File \"shapes.py\", line 38, in area return 0.5 * self.base * self.height AttributeError: 'RightPyramid' object has no attribute 'height' Did you guess that Python will try to call Triangle.area()? This is because of something called the method resolution order. Method Resolution Order The method resolution order (or MRO) tells Python how to search for inherited methods. This comes in handy when you\u2019re using super() because the MRO tells you exactly where Python will look for a method you\u2019re calling with super() and in what order. Every class has an . mro attribute that allows us to inspect the order, so let\u2019s do that: >>> RightPyramid.__mro__ (<class '__main__.RightPyramid'>, <class '__main__.Triangle'>, <class '__main__.Square'>, <class '__main__.Rectangle'>, <class 'object'>) This tells us that methods will be searched first in Rightpyramid, then in Triangle, then in Square, then Rectangle, and then, if nothing is found, in object, from which all classes originate. The problem here is that the interpreter is searching for .area() in Triangle before Square and Rectangle, and upon finding .area() in Triangle, Python calls it instead of the one you want. Because Triangle.area() expects there to be a .height and a .base attribute, Python throws an AttributeError. The problem here is that the interpreter is searching for .area() in Triangle before Square and Rectangle, and upon finding .area() in Triangle, Python calls it instead of the one you want. Because Triangle.area() expects there to be a .height and a .base attribute, Python throws an AttributeError. Luckily, you have some control over how the MRO is constructed. Just by changing the signature of the RightPyramid class, you can search in the order you want, and the methods will resolve correctly: class RightPyramid(Square, Triangle): def __init__(self, base, slant_height): self.base = base self.slant_height = slant_height super().__init__(self.base) def area(self): base_area = super().area() perimeter = super().perimeter() return 0.5 * perimeter * self.slant_height + base_area Notice that RightPyramid initializes partially with the . init () from the Square class. This allows .area() to use the .length on the object, as is designed. Now, you can build a pyramid, inspect the MRO, and calculate the surface area: >>> pyramid = RightPyramid(2, 4) >>> RightPyramid.__mro__ (<class '__main__.RightPyramid'>, <class '__main__.Square'>, <class '__main__.Rectangle'>, <class '__main__.Triangle'>, <class 'object'>) >>> pyramid.area() 20.0 You see that the MRO is now what you\u2019d expect, and you can inspect the area of the pyramid as well, thanks to .area() and .perimeter(). There\u2019s still a problem here, though. For the sake of simplicity, I did a few things wrong in this example: the first, and arguably most importantly, was that I had two separate classes with the same method name and signature. This causes issues with method resolution, because the first instance of .area() that is encountered in the MRO list will be called. When you\u2019re using super() with multiple inheritance, it\u2019s imperative to design your classes to cooperate. Part of this is ensuring that your methods are unique so that they get resolved in the MRO, by making sure method signatures are unique\u2014whether by using method names or method parameters. In this case, to avoid a complete overhaul of your code, you can rename the Triangle class\u2019s .area() method to .tri_area(). This way, the area methods can continue using class properties rather than taking external parameters: class Triangle: def __init__(self, base, height): self.base = base self.height = height super().__init__() def tri_area(self): return 0.5 * self.base * self.height Let\u2019s also go ahead and use this in the RightPyramid class: class RightPyramid(Square, Triangle): def __init__(self, base, slant_height): self.base = base self.slant_height = slant_height super().__init__(self.base) def area(self): base_area = super().area() perimeter = super().perimeter() return 0.5 * perimeter * self.slant_height + base_area def area_2(self): base_area = super().area() triangle_area = super().tri_area() return triangle_area * 4 + base_area The next issue here is that the code doesn\u2019t have a delegated Triangle object like it does for a Square object, so calling .area_2() will give us an AttributeError since .base and .height don\u2019t have any values. You need to do two things to fix this: All methods that are called with super() need to have a call to their superclass\u2019s version of that method. This means that you will need to add super(). init () to the . init () methods of Triangle and Rectangle. Redesign all the . init () calls to take a keyword dictionary. See the complete code below. class Rectangle: def __init__(self, length, width, **kwargs): self.length = length self.width = width super().__init__(**kwargs) def area(self): return self.length * self.width def perimeter(self): return 2 * self.length + 2 * self.width # Here we declare that the Square class inherits from # the Rectangle class class Square(Rectangle): def __init__(self, length, **kwargs): super().__init__(length=length, width=length, **kwargs) class Cube(Square): def surface_area(self): face_area = super().area() return face_area * 6 def volume(self): face_area = super().area() return face_area * self.length class Triangle: def __init__(self, base, height, **kwargs): self.base = base self.height = height super().__init__(**kwargs) def tri_area(self): return 0.5 * self.base * self.height class RightPyramid(Square, Triangle): def __init__(self, base, slant_height, **kwargs): self.base = base self.slant_height = slant_height kwargs[\"height\"] = slant_height kwargs[\"length\"] = base super().__init__(base=base, **kwargs) def area(self): base_area = super().area() perimeter = super().perimeter() return 0.5 * perimeter * self.slant_height + base_area def area_2(self): base_area = super().area() triangle_area = super().tri_area() return triangle_area * 4 + base_area There are a number of important differences in this code: kwargs is modified in some places (such as RightPyramid. init ()): This will allow users of these objects to instantiate them only with the arguments that make sense for that particular object. Setting up named arguments before kwargs: You can see this in RightPyramid. init (). This has the neat effect of popping that key right out of the kwargs dictionary, so that by the time that it ends up at the end of the MRO in the object class, **kwargs is empty. Now, when you use these updated classes, you have this: >>> pyramid = RightPyramid(base=2, slant_height=4) >>> pyramid.area() 20.0 >>> pyramid.area_2() 20.0 It works! You\u2019ve used super() to successfully navigate a complicated class hierarchy while using both inheritance and composition to create new classes with minimal reimplementation. Quiz!!! When Rectangle calls super() what are the values of kwargs and what class gets it's init method called Answer: kwargs is still containing {'base': 2, 'height': 4} values as they haven't been removed from kwargs super().__init__(**kwargs) calls Triangle's init , but Rectangle doesn't inherit from Triangle so why? Remember the MRO? Let's look at RightPyramid's MRO >>> RightPyramid.__mro__ (<class '__main__.RightPyramid'>, <class '__main__.Square'>, <class '__main__.Rectangle'>, <class '__main__.Triangle'>, <class 'object'>) Even though Rectangle doesn't inherit from Triangle, Triangle is next in the list of classes to search for an init method. You'll notice object is at the end of the list. super().__init__(**kwargs) Multiple Inheritance Alternatives As you can see, multiple inheritance can be useful but also lead to very complicated situations and code that is hard to read. It\u2019s also rare to have objects that neatly inherit everything from more than multiple other objects. If you see yourself beginning to use multiple inheritance and a complicated class hierarchy, it\u2019s worth asking yourself if you can achieve code that is cleaner and easier to understand by using composition instead of inheritance. With composition, you can add very specific functionality to your classes from a specialized, simple class called a mixin. Since this article is focused on inheritance, I won\u2019t go into too much detail on composition and how to wield it in Python, but here\u2019s a short example using VolumeMixin to give specific functionality to our 3D objects\u2014in this case, a volume calculation: class Rectangle: def __init__(self, length, width): self.length = length self.width = width def area(self): return self.length * self.width class Square(Rectangle): def __init__(self, length): super().__init__(length, length) class VolumeMixin: def volume(self): return self.area() * self.height class Cube(VolumeMixin, Square): def __init__(self, length): super().__init__(length) self.height = length def face_area(self): return super().area() def surface_area(self): return super().area() * 6 In this example, the code was reworked to include a mixin called VolumeMixin. The mixin is then used by Cube and gives Cube the ability to calculate its volume, which is shown below: >>> cube = Cube(2) >>> cube.surface_area() 24 >>> cube.volume() 8 A super() Recap In this tutorial, you learned how to supercharge your classes with super(). Your journey started with a review of single inheritance and then showed how to call superclass methods easily with super(). You then learned how multiple inheritance works in Python, and techniques to combine super() with multiple inheritance. You also learned about how Python resolves method calls using the method resolution order (MRO), as well as how to inspect and modify the MRO to ensure appropriate methods are called at appropriate times. For more information about object-oriented programming in Python and using super(), check out these resources: Official super() documentation Python\u2019s super() Considered Super by Raymond Hettinger Object-Oriented Programming in Python 3","title":"Multiple Inheritance and Composition"},{"location":"python/advanced/decorators/","text":"@Add_This_Functionality_To_Any_Function! Simple Example: def my_decorator(original_function): def new_function(*args,**kwargs): print(\"you did it!\") of = original_function(*args,**kwargs) return of return new_function @my_decorator def my_func1(stuff): print(\"do things\") @my_decorator def my_func2(stuff): print(\"do things\") @my_decorator def my_func3(stuff): print(\"do things\") my_func1(1);my_func2(1);my_func3(1); Tutorial: We need to discuss global variables and function closure [1] functions: def foo(): return 1; [2] scope a_string = 'this is a string' def foo(): print(locals()) foo() # {} print(globals()) # {..., 'a_string': 'this is a string'} [3] varible resolution rules Local variables with the same name as global ones don't modify the global one. [4] variable lifetime def foo(): x = 1; foo() # NameError: name 'x' is not defined [5] function arguments and parameters def foo(x): print(locals()) foo(1) # {'x': 1} def foo(x, y=0): # remember if no default it's mandatory return x - y foo() # Traceback (most recent call last): # File \"\", line 1, in # TypeError: foo() missing 1 required positional argument: 'x' [6] Nested Functions def outer(): x = 1 def inner(): print(x) inner() outer() # 1 [7] Functions are first class objectsin python # all objects in Python inherit from a common baseclass issubclass(int, object) # True def foo(): pass foo.__class__ # <type 'function'> issubclass(foo.__class__, object) # True #..so what? def add(x,y): return x + y def sub(x,y): return x - y def apply(func, x, y): return func(x, y) apply(add, 2, 1) # 3 apply(sub, 2, 1) # 1 #.. closure lead in def outer(): def inner(): print('this is inner') return inner # the function not what it returns foo = outer() foo # .inner at 0x10be011e0> foo() # 'this is inner' [8] Closures def outer(): x = 1 def inner(): print(x) return inner # the function not what it returns foo = outer() foo.__closure__ # (,) # aside: cell objects are used to store the free variables of a closure # without closures x would have not existed as after the call to outer x is gone based on variable life time. # inner functions defined in non-global scope remember what their enclosing namespaces looked like at definition time. foo() # 1 # let's tweak it def outer(x): def inner(): print(x) return inner print1 = outer(1) print2 = outer(2) print1() # 1 print2() # 2 [9] Decorators def outer(some_func): def inner(): print('before some_func') ret = some_func() # 1 return ret + 1 return inner def foo(): return 1 decorated = outer(foo) decorated() # we've added functionality to foo()! # what if we did this foo = outer(foo) foo() # before some_func # 2 # Let's write a more useful decorator class Coordinate(object): def __init__(self, x, y): self.x = x self.y = y def __repr__(self): return \"Coord: \" + str(self.__dict__) def add(a, b): return Coordinate(a.x + b.x, a.y + b.y) def sub(a, b): return Coordinate(a.x - b.x, a.y - b.y) one = Coordinate(100, 200) two = Coordinate(300, 200) add(one, two) # Coord: {'y': 400, 'x': 400} # add this instance three = Coordinate(-100, -100) def wrapper(func): def checker(a, b): # 1 if a.x < 0 or a.y < 0: a = Coordinate(a.x if a.x > 0 else 0, a.y if a.y > 0 else 0) if b.x < 0 or b.y < 0: b = Coordinate(b.x if b.x > 0 else 0, b.y if b.y > 0 else 0) ret = func(a, b) if ret.x < 0 or ret.y < 0: ret = Coordinate(ret.x if ret.x > 0 else 0, ret.y if ret.y > 0 else 0) return ret return checker add = wrapper(add) sub = wrapper(sub) sub(one, two) add(one, three) [10] the @ symbol # so instead of wrapper(add)\\wrapper(sub), use @wrapper @wrapper def add(a, b): return Coordinate(a.x + b.x, a.y + b.y) @wrapper def sub(a, b): return Coordinate(a.x - b.x, a.y - b.y) [11] args and *kwargs def one(*args): print(args) one() # () one(1,2,3) # (1, 2, 3) def two(x, y, *args): print(x, y, args) two('a','b','c') # Reminder # l = (1,2,3) # one(l[0], l[1], l[2]) # (1, 2, 3) # one(*l) # (1, 2, 3) def foo(**kwargs): print(kwargs) foo() foo(x=1, y=2) [12] More generic decorators def logger(func): def inner(*args, **kwargs): print('Arguments were: {}, {}'.format(args,kwargs)) return func(*args, **kwargs) return inner @logger def foo1(x,y=1): return x * y @logger def foo2(): return 2 foo1(5,4) # Arguments were: (5, 4), {} # 20 foo2() # Arguments were: (), {} # 2","title":"Decorators"},{"location":"python/advanced/decorators/#simple-example","text":"def my_decorator(original_function): def new_function(*args,**kwargs): print(\"you did it!\") of = original_function(*args,**kwargs) return of return new_function @my_decorator def my_func1(stuff): print(\"do things\") @my_decorator def my_func2(stuff): print(\"do things\") @my_decorator def my_func3(stuff): print(\"do things\") my_func1(1);my_func2(1);my_func3(1);","title":"Simple Example:"},{"location":"python/advanced/decorators/#tutorial","text":"We need to discuss global variables and function closure [1] functions: def foo(): return 1; [2] scope a_string = 'this is a string' def foo(): print(locals()) foo() # {} print(globals()) # {..., 'a_string': 'this is a string'} [3] varible resolution rules Local variables with the same name as global ones don't modify the global one. [4] variable lifetime def foo(): x = 1; foo() # NameError: name 'x' is not defined [5] function arguments and parameters def foo(x): print(locals()) foo(1) # {'x': 1} def foo(x, y=0): # remember if no default it's mandatory return x - y foo() # Traceback (most recent call last): # File \"\", line 1, in # TypeError: foo() missing 1 required positional argument: 'x' [6] Nested Functions def outer(): x = 1 def inner(): print(x) inner() outer() # 1 [7] Functions are first class objectsin python # all objects in Python inherit from a common baseclass issubclass(int, object) # True def foo(): pass foo.__class__ # <type 'function'> issubclass(foo.__class__, object) # True #..so what? def add(x,y): return x + y def sub(x,y): return x - y def apply(func, x, y): return func(x, y) apply(add, 2, 1) # 3 apply(sub, 2, 1) # 1 #.. closure lead in def outer(): def inner(): print('this is inner') return inner # the function not what it returns foo = outer() foo # .inner at 0x10be011e0> foo() # 'this is inner' [8] Closures def outer(): x = 1 def inner(): print(x) return inner # the function not what it returns foo = outer() foo.__closure__ # (,) # aside: cell objects are used to store the free variables of a closure # without closures x would have not existed as after the call to outer x is gone based on variable life time. # inner functions defined in non-global scope remember what their enclosing namespaces looked like at definition time. foo() # 1 # let's tweak it def outer(x): def inner(): print(x) return inner print1 = outer(1) print2 = outer(2) print1() # 1 print2() # 2 [9] Decorators def outer(some_func): def inner(): print('before some_func') ret = some_func() # 1 return ret + 1 return inner def foo(): return 1 decorated = outer(foo) decorated() # we've added functionality to foo()! # what if we did this foo = outer(foo) foo() # before some_func # 2 # Let's write a more useful decorator class Coordinate(object): def __init__(self, x, y): self.x = x self.y = y def __repr__(self): return \"Coord: \" + str(self.__dict__) def add(a, b): return Coordinate(a.x + b.x, a.y + b.y) def sub(a, b): return Coordinate(a.x - b.x, a.y - b.y) one = Coordinate(100, 200) two = Coordinate(300, 200) add(one, two) # Coord: {'y': 400, 'x': 400} # add this instance three = Coordinate(-100, -100) def wrapper(func): def checker(a, b): # 1 if a.x < 0 or a.y < 0: a = Coordinate(a.x if a.x > 0 else 0, a.y if a.y > 0 else 0) if b.x < 0 or b.y < 0: b = Coordinate(b.x if b.x > 0 else 0, b.y if b.y > 0 else 0) ret = func(a, b) if ret.x < 0 or ret.y < 0: ret = Coordinate(ret.x if ret.x > 0 else 0, ret.y if ret.y > 0 else 0) return ret return checker add = wrapper(add) sub = wrapper(sub) sub(one, two) add(one, three) [10] the @ symbol # so instead of wrapper(add)\\wrapper(sub), use @wrapper @wrapper def add(a, b): return Coordinate(a.x + b.x, a.y + b.y) @wrapper def sub(a, b): return Coordinate(a.x - b.x, a.y - b.y) [11] args and *kwargs def one(*args): print(args) one() # () one(1,2,3) # (1, 2, 3) def two(x, y, *args): print(x, y, args) two('a','b','c') # Reminder # l = (1,2,3) # one(l[0], l[1], l[2]) # (1, 2, 3) # one(*l) # (1, 2, 3) def foo(**kwargs): print(kwargs) foo() foo(x=1, y=2) [12] More generic decorators def logger(func): def inner(*args, **kwargs): print('Arguments were: {}, {}'.format(args,kwargs)) return func(*args, **kwargs) return inner @logger def foo1(x,y=1): return x * y @logger def foo2(): return 2 foo1(5,4) # Arguments were: (5, 4), {} # 20 foo2() # Arguments were: (), {} # 2","title":"Tutorial:"},{"location":"python/base_modules/collections/counter/","text":"Counter Class Intro Counter is a dict subclass for counting hashable objects: >>> c = Counter() # a new, empty counter >>> c Counter() >>> c = Counter('gallahad') # a new counter from an iterable >>> c Counter({'a': 3, 'l': 2, 'g': 1, 'h': 1, 'd': 1}) # a new counter from a mapping >>> c = Counter({'red': 4, 'blue': 2}) # a new counter from a mapping >>> c Counter({'red': 4, 'blue': 2}) >>> c = Counter(cats=4, dogs=8) # a new counter from keyword args >>> c Counter({'dogs': 8, 'cats': 4}) >>> Counter([1,2,2,3,3,3,4,4,4,4]) Counter({4: 4, 3: 3, 2: 2, 1: 1}) Delete objects as shown below: # Delete records as shown below: >>> c = Counter(['eggs', 'ham']) >>> c Counter({'eggs': 1, 'ham': 1}) >>> del c['ham'] >>> c Counter({'eggs': 1}) Counter objects support three methods beyond those available for all dictionaries: elements() Return an iterator over elements repeating each as many times as its count. Elements are returned in arbitrary order. If an element\u2019s count is less than one, elements() will ignore it. >>> c = Counter(a=4, b=2, c=0, d=-2) >>> list(c.elements()) ['a', 'a', 'a', 'a', 'b', 'b'] most_common([n]) Return a list of the n most common elements and their counts from the most common to the least. If n is omitted or None, most_common() returns all elements in the counter. Elements with equal counts are ordered arbitrarily: >>> Counter('abracadabra').most_common(3) [('a', 5), ('r', 2), ('b', 2)] subtract([iterable-or-mapping]) Elements are subtracted from an iterable or from another mapping (or counter). Like dict.update() but subtracts counts instead of replacing them. Both inputs and outputs may be zero or negative. >>> c = Counter(a=4, b=2, c=0, d=-2) >>> d = Counter(a=1, b=2, c=3, d=4) >>> c.subtract(d) >>> c Counter({'a': 3, 'b': 0, 'c': -3, 'd': -6})","title":"counter()"},{"location":"python/base_modules/collections/counter/#intro","text":"Counter is a dict subclass for counting hashable objects: >>> c = Counter() # a new, empty counter >>> c Counter() >>> c = Counter('gallahad') # a new counter from an iterable >>> c Counter({'a': 3, 'l': 2, 'g': 1, 'h': 1, 'd': 1}) # a new counter from a mapping >>> c = Counter({'red': 4, 'blue': 2}) # a new counter from a mapping >>> c Counter({'red': 4, 'blue': 2}) >>> c = Counter(cats=4, dogs=8) # a new counter from keyword args >>> c Counter({'dogs': 8, 'cats': 4}) >>> Counter([1,2,2,3,3,3,4,4,4,4]) Counter({4: 4, 3: 3, 2: 2, 1: 1})","title":"Intro"},{"location":"python/base_modules/collections/counter/#delete-objects-as-shown-below","text":"# Delete records as shown below: >>> c = Counter(['eggs', 'ham']) >>> c Counter({'eggs': 1, 'ham': 1}) >>> del c['ham'] >>> c Counter({'eggs': 1}) Counter objects support three methods beyond those available for all dictionaries:","title":"Delete objects as shown below:"},{"location":"python/base_modules/collections/counter/#elements","text":"Return an iterator over elements repeating each as many times as its count. Elements are returned in arbitrary order. If an element\u2019s count is less than one, elements() will ignore it. >>> c = Counter(a=4, b=2, c=0, d=-2) >>> list(c.elements()) ['a', 'a', 'a', 'a', 'b', 'b']","title":"elements()"},{"location":"python/base_modules/collections/counter/#most_commonn","text":"Return a list of the n most common elements and their counts from the most common to the least. If n is omitted or None, most_common() returns all elements in the counter. Elements with equal counts are ordered arbitrarily: >>> Counter('abracadabra').most_common(3) [('a', 5), ('r', 2), ('b', 2)]","title":"most_common([n])"},{"location":"python/base_modules/collections/counter/#subtractiterable-or-mapping","text":"Elements are subtracted from an iterable or from another mapping (or counter). Like dict.update() but subtracts counts instead of replacing them. Both inputs and outputs may be zero or negative. >>> c = Counter(a=4, b=2, c=0, d=-2) >>> d = Counter(a=1, b=2, c=3, d=4) >>> c.subtract(d) >>> c Counter({'a': 3, 'b': 0, 'c': -3, 'd': -6})","title":"subtract([iterable-or-mapping])"},{"location":"python/base_modules/collections/default_dict/","text":"Initialize dictionary values with a data type. Returns a new dictionary-like object. defaultdict is a subclass of the built-in dict class. The first argument provides the initial value for the default_factory attribute; it defaults to None . All remaining arguments are treated the same as if they were passed to the dict constructor, including keyword arguments. from collections import defaultdict # Try to append all numbers in a list to their descriptions s = [('yellow', 1), ('blue', 2), ('yellow', 3), ('blue', 4), ('red', 1)] d = {} for k, v in s: d[k].append(v) # You can't because there is no default data type for the values of the keys being created. >>> Traceback (most recent call last): File \"\", line 1, in File \"\", line 6, in KeyError: 'yellow' # Use a default dict to accomplish this: s = [('yellow', 1), ('blue', 2), ('yellow', 3), ('blue', 4), ('red', 1)] d = defaultdict(list) for k, v in s: d[k].append(v) >>> d defaultdict(, {'yellow': [1, 3], 'blue': [2, 4], 'red': [1]}) # You can accomplish this with the base dictionary like this: >>> d = {} >>> d.setdefault('yellow', []) [] >>> d {'yellow': []} or >>> d = {} >>> d.setdefault('yellow', list) >>> d {'yellow': } # ...and our previous example: s = [('yellow', 1), ('blue', 2), ('yellow', 3), ('blue', 4), ('red', 1)] d = {} for k, v in s: d.setdefault(k, []).append(v) >>> d {'yellow': [1, 3], 'blue': [2, 4], 'red': [1]}","title":"default_dict()"},{"location":"python/useful/args_kwargs/","text":"Passing unknown amounts of inputs to a function *args - any number of inputs of any data type. They will be referenced in order with indicies being of the form args[0]...etc. **kwargs - The same as above but with key work arguments, so you would be able to access elements by key name. kwargs The * is important as it signifies if args or kwargs are being used. Otherwise this happens: >>> def prac(*args): ... for i in args: ... print(\"This arg is :{}\".format(i)) ... >>> prac([1,2,3,4,5]) This arg is :[1, 2, 3, 4, 5] # ooooops! >>> prac(*[1,2,3,4,5]) This arg is :1 This arg is :2 This arg is :3 This arg is :4 This arg is :5 >>> def prac(**kwargs): ... for k in kwargs.keys(): ... print(kwargs[k]) ... >>> prac(**{'A':1,'B':2}) 1 2 Also note iterables are acceptible inputs: >>> prac(*[1,2,3,4,5]) This arg is :1 This arg is :2 This arg is :3 This arg is :4 This arg is :5 >>> prac(*(1,2,3,4,5)) This arg is :1 This arg is :2 This arg is :3 This arg is :4 This arg is :5 >>> prac(*{1,2,3,4,5}) This arg is :1 This arg is :2 This arg is :3 This arg is :4 This arg is :5 >>> prac(*range(1,6)) This arg is :1 This arg is :2 This arg is :3 This arg is :4 This arg is :5 Below are additional examples def f(*args,**kwargs): print(args, kwargs) l = [1,2,3] t = (4,5,6) d = {'a':7,'b':8,'c':9} f() # () {} f(1,2,3) # (1, 2, 3) {} f(1,2,3,\"groovy\") # (1, 2, 3, 'groovy') {} f(a=1,b=2,c=3) # () {'a': 1, 'c': 3, 'b': 2} f(a=1,b=2,c=3,zzz=\"hi\") # () {'a': 1, 'c': 3, 'b': 2, 'zzz': 'hi'} f(1,2,3,a=1,b=2,c=3) # (1, 2, 3) {'a': 1, 'c': 3, 'b': 2} f(*l,**d) # (1, 2, 3) {'a': 7, 'c': 9, 'b': 8} f(*t,**d) # (4, 5, 6) {'a': 7, 'c': 9, 'b': 8} f(1,2,*t) # (1, 2, 4, 5, 6) {} f(q=\"winning\",**d) # () {'a': 7, 'q': 'winning', 'c': 9, 'b': 8} f(1,2,*t,q=\"winning\",**d) # (1, 2, 4, 5, 6) {'a': 7, 'q': 'winning', 'c': 9, 'b': 8} def f2(arg1,arg2,*args,**kwargs): print(arg1,arg2, args, kwargs) f2(1,2,3) # 1 2 (3,) {} f2(1,2,3,\"groovy\") # 1 2 (3, 'groovy') {} f2(arg1=1,arg2=2,c=3) # 1 2 () {'c': 3} f2(arg1=1,arg2=2,c=3,zzz=\"hi\") # 1 2 () {'c': 3, 'zzz': 'hi'} f2(1,2,3,a=1,b=2,c=3) # 1 2 (3,) {'a': 1, 'c': 3, 'b': 2} f2(*l,**d) # 1 2 (3,) {'a': 7, 'c': 9, 'b': 8} f2(*t,**d) # 4 5 (6,) {'a': 7, 'c': 9, 'b': 8} f2(1,2,*t) # 1 2 (4, 5, 6) {} f2(1,1,q=\"winning\",**d) # 1 1 () {'a': 7, 'q': 'winning', 'c': 9, 'b': 8} f2(1,2,*t,q=\"winning\",**d) # 1 2 (4, 5, 6) {'a': 7, 'q': 'winning', 'c': 9, 'b': 8}","title":"args, kwargs"},{"location":"python/useful/input/","text":"Here we show how to accept user input print('Enter your name:') x = input() print('Hello, ' + x) >>> Enter your name: Ben Hello, Ben","title":"input()"},{"location":"python/useful/map/","text":"map() allows us to apply a function to a list of items # Simple Example >>> list(map(float, ['1.0', '2.0'])) [1.0, 2.0] # Turn this: items = [1, 2, 3, 4, 5] squared = [] for i in items: squared.append(i**2) # Into this with a lambda function: items = [1, 2, 3, 4, 5] squared = list(map(lambda x: x**2, items))","title":"map()"},{"location":"python/useful/pass_by_reference/","text":"Pass By Reference Python will pass values between objects as references to their memory position. Addresses not values are passed...except for primitives.. An example: def f(x,l=[]): for i in range(x): l.append(i*i) print(l) f(2) # [0, 1] f(3,[3,2,1]) # [3, 2, 1, 0, 1, 4] Here python treats the variable l as a fresh list because a fresh list or more accurately, it's location in memory was passed. See python created [3, 2, 1] separately and passed it's location to the function. Watch what happends when we call the function again with no list. f(3) # [0, 1, 0, 1, 4] why not [0,1,4]?. When the function was first called we created the default list \"l=[]\", and according to the function's directions, by default this function refers to that list's memory position. Check out the following examples of pythons memory usage for this example: l_mem = [] l = l_mem # the first call for i in range(2): l.append(i*i) print(l) # [0, 1] l = [3,2,1] # the second call for i in range(3): l.append(i*i) print(l) # [3, 2, 1, 0, 1, 4] l = l_mem # the third call for i in range(3): l.append(i*i) print(l) # [0, 1, 0, 1, 4]","title":"P.B. Reference"},{"location":"python/useful/sets/","text":"Sets In Python A Set is an unordered collection data type that is iterable, mutable, and has no duplicate elements. Python\u2019s set class represents the mathematical notion of a set. The major advantage of using a set, as opposed to a list, is that it has a highly optimized method for checking whether a specific element is contained in the set. This is based on a data structure known as a hash table. Methods: add() add(x) Method: Adds the item x to set if it is not already present in the set. >>> s3.add(9) >>> s3 {9, 3} 2. union(s) Method: Returns a union of two set.Using the \u2018|\u2019 operator between 2 sets is the same as writing set1.union(set2) union() >>> s1.union(s2) {1, 2, 3, 4, 5} >>> s1 | s2 {1, 2, 3, 4, 5} 3. intersect(s) Method: Returns an intersection of two sets.The \u2018&\u2019 operator comes can also be used in this case. intersection() >>> s1.intersection(s2) {3} >>> s1 & s2 {3} difference difference(s) Method: Returns a set containing all the elements of invoking set but not of the second set. We can use \u2018-\u2018 operator here. >>> s1.difference(s2) {1, 2} >>> s1 - s2 {1, 2} 5. clear() Method: Empties the whole set. >>> s1.clear() >>> s2.clear() >>> s1 set() >>> s2 set() discard() discard() Method: The discard() method takes a single element x and removes it from the set (if present). >>> s1 {1, 2, 3} >>> s1.discard(1) >>> s1 {2, 3} issubset() issubset() Method: The issubset() method returns True if all elements of a set are present in another set (passed as an argument). If not, it returns False. >>> s1 {1, 2, 3} >>> s1.issubset({1,2,3,4}) True Operators for Sets Sets and frozen sets support the following operators: >>> k = 1 >>> key in s1 # containment check True >>> key not in s1 # non-containment check False >>> s1 == s2 # s1 is equivalent to s2 False >>> s1 != s2 # s1 is not equivalent to s2 True >>> s1 <= s2 # s1 is subset of s2 False >>> s1 < s2 # s1 is proper subset of s2 False >>> s1 >= s2 # s1 is superset of s2 False >>> s1 > s2 # s1 is proper superset of s2 False >>> s1 | s2 # the union of s1 and s2 {1, 2, 3, 4, 5} >>> s1 & s2 # the intersection of s1 and s2 {3} >>> s1 - s2 # the set of elements in s1 but not s2 {1, 2} >>> s1 ^ s2 # the set of elements in precisely one of s1 or s2 {1, 2, 4, 5}","title":"Sets"},{"location":"python/useful/sets/#add","text":"add(x) Method: Adds the item x to set if it is not already present in the set. >>> s3.add(9) >>> s3 {9, 3} 2. union(s) Method: Returns a union of two set.Using the \u2018|\u2019 operator between 2 sets is the same as writing set1.union(set2)","title":"add()"},{"location":"python/useful/sets/#union","text":">>> s1.union(s2) {1, 2, 3, 4, 5} >>> s1 | s2 {1, 2, 3, 4, 5} 3. intersect(s) Method: Returns an intersection of two sets.The \u2018&\u2019 operator comes can also be used in this case.","title":"union()"},{"location":"python/useful/sets/#intersection","text":">>> s1.intersection(s2) {3} >>> s1 & s2 {3}","title":"intersection()"},{"location":"python/useful/sets/#difference","text":"difference(s) Method: Returns a set containing all the elements of invoking set but not of the second set. We can use \u2018-\u2018 operator here. >>> s1.difference(s2) {1, 2} >>> s1 - s2 {1, 2} 5. clear() Method: Empties the whole set. >>> s1.clear() >>> s2.clear() >>> s1 set() >>> s2 set()","title":"difference"},{"location":"python/useful/sets/#discard","text":"discard() Method: The discard() method takes a single element x and removes it from the set (if present). >>> s1 {1, 2, 3} >>> s1.discard(1) >>> s1 {2, 3}","title":"discard()"},{"location":"python/useful/sets/#issubset","text":"issubset() Method: The issubset() method returns True if all elements of a set are present in another set (passed as an argument). If not, it returns False. >>> s1 {1, 2, 3} >>> s1.issubset({1,2,3,4}) True Operators for Sets Sets and frozen sets support the following operators: >>> k = 1 >>> key in s1 # containment check True >>> key not in s1 # non-containment check False >>> s1 == s2 # s1 is equivalent to s2 False >>> s1 != s2 # s1 is not equivalent to s2 True >>> s1 <= s2 # s1 is subset of s2 False >>> s1 < s2 # s1 is proper subset of s2 False >>> s1 >= s2 # s1 is superset of s2 False >>> s1 > s2 # s1 is proper superset of s2 False >>> s1 | s2 # the union of s1 and s2 {1, 2, 3, 4, 5} >>> s1 & s2 # the intersection of s1 and s2 {3} >>> s1 - s2 # the set of elements in s1 but not s2 {1, 2} >>> s1 ^ s2 # the set of elements in precisely one of s1 or s2 {1, 2, 4, 5}","title":"issubset()"},{"location":"python/useful/sorted/","text":"Sort Arrays Want to sort something, sorted() is a great start. Syntax: sorted(iterable, key, reverse) Parameters: sorted takes three parameters from which two are optional. Iterable: sequence (list, tuple, string) or collection (dictionary, set, frozenset) or any other iterator that needs to be sorted Key(optional) : A function that would server as a key or a basis of sort comparison Reverse(optional) : If set true, then the iterable would be sorted in reverse (descending) order, by default it is set as false Note: A list also has sort() method which performs the same way as sorted(). Only difference being, sort() method doesn't return any value and changes the original list itself. x = [2,44,3,87,5] print(x) # [2, 44, 3, 87, 5] print(sorted(x)) #[2, 3, 5, 44, 87] print(sorted(x, reverse=True)) # [87, 44, 5, 3, 2] Custom Sorting using the key parameter: sorted() function has an optional parameter called \u2018key\u2019 which takes a function as its value. This key function transforms each element before sorting, it takes the value and returns 1 value which is then used within sort instead of the original value. For example, if we pass a list of strings in sorted(), it gets sorted alphabetically . But if we specify key = len, i.e. give len function as key, then the strings would be passed to len, and the value it returns, i.e. the length of strings will be sorted. Which means that the strings would be sorted based on their lengths instead # sort by your own criteria L = [\"cccc\", \"b\", \"dd\", \"aaa\"] print(\"Normal sort :\", sorted(L)) print(\"Sort with len :\", sorted(L, key = len))","title":"sorted()"},{"location":"python/useful/zip/","text":"Combine iterables and return them as tuple sets. The zip() function returns an iterator of tuples based on the iterable object. If no parameters are passed, zip() returns an empty iterator If a single iterable is passed, zip() returns an iterator of 1-tuples. Meaning, the number of elements in each tuple is 1 If multiple iterables are passed, ith tuple contains ith iterable values from all iterables. Suppose, two iterables are passed; one iterable containing 3 and other containing 5 elements, then the returned iterator will have 3 tuples >>> zip() <zip object at 0x102c9be48> # length 0 >>> list(zip()) [] # length 1 >>> list(zip([1,2,3])) [(1,), (2,), (3,)] # same length iterables >>> x, y = [1,2,3], [4,5,6] >>> list(zip(x,y)) [(1, 4), (2, 5), (3, 6)] # different length iterables >>> x, y = [1,2,3], [4,5,6,7] >>> list(zip(x,y)) [(1, 4), (2, 5), (3, 6)] iterables - can be built-in iterables (like: list, set, tuple, string, dict...), or user-defined iterables (object that has iter method). x, y, z = [1,2,3], [4,5,6], {'a':4,'b':5,'c':6} # dictionaries use keys by default results_default = set(zip(x,y,z)) results_2 = set(zip(x,y,z.keys())) results_3 = set(zip(x,y,z.values())) print(results_default) # {(3, 6, 'c'), (1, 4, 'a'), (2, 5, 'b')} print(results_2) # {(3, 6, 'c'), (1, 4, 'a'), (2, 5, 'b')} print(results_3) # {(1, 4, 4), (3, 6, 6), (2, 5, 5)} View the zip contents with a list or set or tuple data type: >>> list(zip(x,y)) [(1, 4), (2, 5), (3, 6)] >>> set(zip(x,y)) {(2, 5), (3, 6), (1, 4)} >>> tuple(zip(x,y)) ((1, 4), (2, 5), (3, 6)) Unzipping is possible too: > x [1, 2, 3] >>> y [4, 5, 6, 7] >>> list(zip(x,y)) [(1, 4), (2, 5), (3, 6)] # Use * to unzip a zip object. You have to call zip() as a wrapper for *zip(). >>> list(zip(*zip(x,y))) [(1, 2, 3), (4, 5, 6)] >>> zip(*zip(x,y)) <zip object at 0x102ccb888> # The zip object is automatically unpacked into a nd b. >>> a,b = zip(*zip(x,y)) >>> a (1, 2, 3) >>> b (4, 5, 6) >>> Watch what happens when you try to view a zip object with a dictionary: >>> dict(zip([1,2],['a','b'])) {1: 'a', 2: 'b'} We can create dictionaries from individual unassociated key, values lists!","title":"zip()"},{"location":"sql/postgres/postgres/","text":"Postgres Obscura ipsa veteris augebat vias Lorem markdownum in sucis amore fuerat: cum simul adnuit. Vigor levat, aurigenae regis longo, annos ver gerit. Ab Troiam tertius nonne, si arma; novi ille flatuque aures crus fugit aperit sed. jsonWpaDefragment += language_clean - yottabyte_memory.ics(laser * 35, dropBank, megabyteTypeface); memorySoftwareTiff = drive_visual_unix; infringement = dlc.hashtag_frequency_link(-5, cache); var scareware_desktop = cpmBinPowerpoint( cookie_windows.keystroke_torrent_page(wpa, flowchartParityFile) - 78); Illum et equos longa fictus dixit Coniuge et quoque neve, vices et eripitur excidit cernis longa solis tibi! Quae tympana abeunt exhalantes est pictae carinas seque remanente placere filia, sinat, exceptas. Tam loco quis quoque timeri pallor deperderet pavefacta haud responsa? Vocat abest habet terram attonitas nobis turba referebat utrique aliisque enim formaeque contingere omnes. Mero intervenit magno: nomen quo liquores nec, e trahentem. megabyte -= cableShiftPublic.market(sdOpenOnly.mebibyteFolder( service_terabyte_registry, ddr, mp_vpi_bus), memoryWirelessArt * modeServerCrossplatform); icfFileAnd = refreshTutorialPup; sipPowerRw(2 - 4, of); wamp_ppc_topology = wordNntpPack; Dedisset tantus ora di tectis arcumque vario Et iussa me quicquam se Dauno mediis daulida. Qui auras habet sua confessaque, resurgebant innumerae messes quidem cui calcitrat ut ducit ! Dominae sistetur cohibentem blanditiis labuntur medullis flammas; spectavit finemque unus; nymphe infelix quoque, delubraque causa: hic. Hoc quod decus quaque iactata rerum premis blandas in tertia fixa delphines liquido gemini peragebant veniet aequor cursus fieri. Est cernit Amphrysi in moenia tum certamine Parsque conplexae salices hoc Hac habes videre lumina transmittere illic lambentem Visa famulae Planxitque magno proles levatus legendo cavernis tympana: et et igitur ut unda et gaudent? Iuventus crevit in me medicas dextra peperisse trepidantum nullo vulneribus Parnasos mentisque numero in . Solet cernis maiores media moles haec alios addunt quaque, tingui.","title":"Postgres"},{"location":"sql/postgres/postgres/#postgres","text":"","title":"Postgres"},{"location":"sql/postgres/postgres/#obscura-ipsa-veteris-augebat-vias","text":"Lorem markdownum in sucis amore fuerat: cum simul adnuit. Vigor levat, aurigenae regis longo, annos ver gerit. Ab Troiam tertius nonne, si arma; novi ille flatuque aures crus fugit aperit sed. jsonWpaDefragment += language_clean - yottabyte_memory.ics(laser * 35, dropBank, megabyteTypeface); memorySoftwareTiff = drive_visual_unix; infringement = dlc.hashtag_frequency_link(-5, cache); var scareware_desktop = cpmBinPowerpoint( cookie_windows.keystroke_torrent_page(wpa, flowchartParityFile) - 78);","title":"Obscura ipsa veteris augebat vias"},{"location":"sql/postgres/postgres/#illum-et-equos-longa-fictus-dixit","text":"Coniuge et quoque neve, vices et eripitur excidit cernis longa solis tibi! Quae tympana abeunt exhalantes est pictae carinas seque remanente placere filia, sinat, exceptas. Tam loco quis quoque timeri pallor deperderet pavefacta haud responsa? Vocat abest habet terram attonitas nobis turba referebat utrique aliisque enim formaeque contingere omnes. Mero intervenit magno: nomen quo liquores nec, e trahentem. megabyte -= cableShiftPublic.market(sdOpenOnly.mebibyteFolder( service_terabyte_registry, ddr, mp_vpi_bus), memoryWirelessArt * modeServerCrossplatform); icfFileAnd = refreshTutorialPup; sipPowerRw(2 - 4, of); wamp_ppc_topology = wordNntpPack;","title":"Illum et equos longa fictus dixit"},{"location":"sql/postgres/postgres/#dedisset-tantus-ora-di-tectis-arcumque-vario","text":"Et iussa me quicquam se Dauno mediis daulida. Qui auras habet sua confessaque, resurgebant innumerae messes quidem cui calcitrat ut ducit ! Dominae sistetur cohibentem blanditiis labuntur medullis flammas; spectavit finemque unus; nymphe infelix quoque, delubraque causa: hic. Hoc quod decus quaque iactata rerum premis blandas in tertia fixa delphines liquido gemini peragebant veniet aequor cursus fieri. Est cernit Amphrysi in moenia tum certamine Parsque conplexae salices hoc Hac habes videre lumina transmittere illic lambentem Visa famulae Planxitque magno proles levatus legendo cavernis tympana: et et igitur ut unda et gaudent? Iuventus crevit in me medicas dextra peperisse trepidantum nullo vulneribus Parnasos mentisque numero in . Solet cernis maiores media moles haec alios addunt quaque, tingui.","title":"Dedisset tantus ora di tectis arcumque vario"},{"location":"sql/sql_server/sql_server/","text":"SQL Server Obscura ipsa veteris augebat vias Lorem markdownum in sucis amore fuerat: cum simul adnuit. Vigor levat, aurigenae regis longo, annos ver gerit. Ab Troiam tertius nonne, si arma; novi ille flatuque aures crus fugit aperit sed. jsonWpaDefragment += language_clean - yottabyte_memory.ics(laser * 35, dropBank, megabyteTypeface); memorySoftwareTiff = drive_visual_unix; infringement = dlc.hashtag_frequency_link(-5, cache); var scareware_desktop = cpmBinPowerpoint( cookie_windows.keystroke_torrent_page(wpa, flowchartParityFile) - 78); Illum et equos longa fictus dixit Coniuge et quoque neve, vices et eripitur excidit cernis longa solis tibi! Quae tympana abeunt exhalantes est pictae carinas seque remanente placere filia, sinat, exceptas. Tam loco quis quoque timeri pallor deperderet pavefacta haud responsa? Vocat abest habet terram attonitas nobis turba referebat utrique aliisque enim formaeque contingere omnes. Mero intervenit magno: nomen quo liquores nec, e trahentem. megabyte -= cableShiftPublic.market(sdOpenOnly.mebibyteFolder( service_terabyte_registry, ddr, mp_vpi_bus), memoryWirelessArt * modeServerCrossplatform); icfFileAnd = refreshTutorialPup; sipPowerRw(2 - 4, of); wamp_ppc_topology = wordNntpPack; Dedisset tantus ora di tectis arcumque vario Et iussa me quicquam se Dauno mediis daulida. Qui auras habet sua confessaque, resurgebant innumerae messes quidem cui calcitrat ut ducit ! Dominae sistetur cohibentem blanditiis labuntur medullis flammas; spectavit finemque unus; nymphe infelix quoque, delubraque causa: hic. Hoc quod decus quaque iactata rerum premis blandas in tertia fixa delphines liquido gemini peragebant veniet aequor cursus fieri. Est cernit Amphrysi in moenia tum certamine Parsque conplexae salices hoc Hac habes videre lumina transmittere illic lambentem Visa famulae Planxitque magno proles levatus legendo cavernis tympana: et et igitur ut unda et gaudent? Iuventus crevit in me medicas dextra peperisse trepidantum nullo vulneribus Parnasos mentisque numero in . Solet cernis maiores media moles haec alios addunt quaque, tingui.","title":"SQL server"},{"location":"sql/sql_server/sql_server/#sql-server","text":"","title":"SQL Server"},{"location":"sql/sql_server/sql_server/#obscura-ipsa-veteris-augebat-vias","text":"Lorem markdownum in sucis amore fuerat: cum simul adnuit. Vigor levat, aurigenae regis longo, annos ver gerit. Ab Troiam tertius nonne, si arma; novi ille flatuque aures crus fugit aperit sed. jsonWpaDefragment += language_clean - yottabyte_memory.ics(laser * 35, dropBank, megabyteTypeface); memorySoftwareTiff = drive_visual_unix; infringement = dlc.hashtag_frequency_link(-5, cache); var scareware_desktop = cpmBinPowerpoint( cookie_windows.keystroke_torrent_page(wpa, flowchartParityFile) - 78);","title":"Obscura ipsa veteris augebat vias"},{"location":"sql/sql_server/sql_server/#illum-et-equos-longa-fictus-dixit","text":"Coniuge et quoque neve, vices et eripitur excidit cernis longa solis tibi! Quae tympana abeunt exhalantes est pictae carinas seque remanente placere filia, sinat, exceptas. Tam loco quis quoque timeri pallor deperderet pavefacta haud responsa? Vocat abest habet terram attonitas nobis turba referebat utrique aliisque enim formaeque contingere omnes. Mero intervenit magno: nomen quo liquores nec, e trahentem. megabyte -= cableShiftPublic.market(sdOpenOnly.mebibyteFolder( service_terabyte_registry, ddr, mp_vpi_bus), memoryWirelessArt * modeServerCrossplatform); icfFileAnd = refreshTutorialPup; sipPowerRw(2 - 4, of); wamp_ppc_topology = wordNntpPack;","title":"Illum et equos longa fictus dixit"},{"location":"sql/sql_server/sql_server/#dedisset-tantus-ora-di-tectis-arcumque-vario","text":"Et iussa me quicquam se Dauno mediis daulida. Qui auras habet sua confessaque, resurgebant innumerae messes quidem cui calcitrat ut ducit ! Dominae sistetur cohibentem blanditiis labuntur medullis flammas; spectavit finemque unus; nymphe infelix quoque, delubraque causa: hic. Hoc quod decus quaque iactata rerum premis blandas in tertia fixa delphines liquido gemini peragebant veniet aequor cursus fieri. Est cernit Amphrysi in moenia tum certamine Parsque conplexae salices hoc Hac habes videre lumina transmittere illic lambentem Visa famulae Planxitque magno proles levatus legendo cavernis tympana: et et igitur ut unda et gaudent? Iuventus crevit in me medicas dextra peperisse trepidantum nullo vulneribus Parnasos mentisque numero in . Solet cernis maiores media moles haec alios addunt quaque, tingui.","title":"Dedisset tantus ora di tectis arcumque vario"},{"location":"sql/sqlite/sqlite/","text":"sqlite Obscura ipsa veteris augebat vias Lorem markdownum in sucis amore fuerat: cum simul adnuit. Vigor levat, aurigenae regis longo, annos ver gerit. Ab Troiam tertius nonne, si arma; novi ille flatuque aures crus fugit aperit sed. jsonWpaDefragment += language_clean - yottabyte_memory.ics(laser * 35, dropBank, megabyteTypeface); memorySoftwareTiff = drive_visual_unix; infringement = dlc.hashtag_frequency_link(-5, cache); var scareware_desktop = cpmBinPowerpoint( cookie_windows.keystroke_torrent_page(wpa, flowchartParityFile) - 78); Illum et equos longa fictus dixit Coniuge et quoque neve, vices et eripitur excidit cernis longa solis tibi! Quae tympana abeunt exhalantes est pictae carinas seque remanente placere filia, sinat, exceptas. Tam loco quis quoque timeri pallor deperderet pavefacta haud responsa? Vocat abest habet terram attonitas nobis turba referebat utrique aliisque enim formaeque contingere omnes. Mero intervenit magno: nomen quo liquores nec, e trahentem. megabyte -= cableShiftPublic.market(sdOpenOnly.mebibyteFolder( service_terabyte_registry, ddr, mp_vpi_bus), memoryWirelessArt * modeServerCrossplatform); icfFileAnd = refreshTutorialPup; sipPowerRw(2 - 4, of); wamp_ppc_topology = wordNntpPack; Dedisset tantus ora di tectis arcumque vario Et iussa me quicquam se Dauno mediis daulida. Qui auras habet sua confessaque, resurgebant innumerae messes quidem cui calcitrat ut ducit ! Dominae sistetur cohibentem blanditiis labuntur medullis flammas; spectavit finemque unus; nymphe infelix quoque, delubraque causa: hic. Hoc quod decus quaque iactata rerum premis blandas in tertia fixa delphines liquido gemini peragebant veniet aequor cursus fieri. Est cernit Amphrysi in moenia tum certamine Parsque conplexae salices hoc Hac habes videre lumina transmittere illic lambentem Visa famulae Planxitque magno proles levatus legendo cavernis tympana: et et igitur ut unda et gaudent? Iuventus crevit in me medicas dextra peperisse trepidantum nullo vulneribus Parnasos mentisque numero in . Solet cernis maiores media moles haec alios addunt quaque, tingui.","title":"sqlite"},{"location":"sql/sqlite/sqlite/#sqlite","text":"","title":"sqlite"},{"location":"sql/sqlite/sqlite/#obscura-ipsa-veteris-augebat-vias","text":"Lorem markdownum in sucis amore fuerat: cum simul adnuit. Vigor levat, aurigenae regis longo, annos ver gerit. Ab Troiam tertius nonne, si arma; novi ille flatuque aures crus fugit aperit sed. jsonWpaDefragment += language_clean - yottabyte_memory.ics(laser * 35, dropBank, megabyteTypeface); memorySoftwareTiff = drive_visual_unix; infringement = dlc.hashtag_frequency_link(-5, cache); var scareware_desktop = cpmBinPowerpoint( cookie_windows.keystroke_torrent_page(wpa, flowchartParityFile) - 78);","title":"Obscura ipsa veteris augebat vias"},{"location":"sql/sqlite/sqlite/#illum-et-equos-longa-fictus-dixit","text":"Coniuge et quoque neve, vices et eripitur excidit cernis longa solis tibi! Quae tympana abeunt exhalantes est pictae carinas seque remanente placere filia, sinat, exceptas. Tam loco quis quoque timeri pallor deperderet pavefacta haud responsa? Vocat abest habet terram attonitas nobis turba referebat utrique aliisque enim formaeque contingere omnes. Mero intervenit magno: nomen quo liquores nec, e trahentem. megabyte -= cableShiftPublic.market(sdOpenOnly.mebibyteFolder( service_terabyte_registry, ddr, mp_vpi_bus), memoryWirelessArt * modeServerCrossplatform); icfFileAnd = refreshTutorialPup; sipPowerRw(2 - 4, of); wamp_ppc_topology = wordNntpPack;","title":"Illum et equos longa fictus dixit"},{"location":"sql/sqlite/sqlite/#dedisset-tantus-ora-di-tectis-arcumque-vario","text":"Et iussa me quicquam se Dauno mediis daulida. Qui auras habet sua confessaque, resurgebant innumerae messes quidem cui calcitrat ut ducit ! Dominae sistetur cohibentem blanditiis labuntur medullis flammas; spectavit finemque unus; nymphe infelix quoque, delubraque causa: hic. Hoc quod decus quaque iactata rerum premis blandas in tertia fixa delphines liquido gemini peragebant veniet aequor cursus fieri. Est cernit Amphrysi in moenia tum certamine Parsque conplexae salices hoc Hac habes videre lumina transmittere illic lambentem Visa famulae Planxitque magno proles levatus legendo cavernis tympana: et et igitur ut unda et gaudent? Iuventus crevit in me medicas dextra peperisse trepidantum nullo vulneribus Parnasos mentisque numero in . Solet cernis maiores media moles haec alios addunt quaque, tingui.","title":"Dedisset tantus ora di tectis arcumque vario"}]}