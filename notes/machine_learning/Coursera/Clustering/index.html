<!DOCTYPE html>
<html lang="en">
<head>
  
  
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    
    
    <link rel="shortcut icon" href="../../../../img/favicon.ico">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
    <title>8. Clustering - Ben's Code Journal</title>
    <link href="../../../../css/bootstrap-3.3.7.min.css" rel="stylesheet">
    <link href="../../../../css/font-awesome-4.7.0.css" rel="stylesheet">
    <link href="../../../../css/base.css" rel="stylesheet">
    <link rel="stylesheet" href="../../../../css/highlight.css">
    <link href="../../../../css/extra.css" rel="stylesheet">
    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
    <![endif]-->

    <script src="../../../../js/jquery-3.2.1.min.js"></script>
    <script src="../../../../js/bootstrap-3.3.7.min.js"></script>
    <script src="../../../../js/highlight.pack.js"></script>
    
    <base target="_top">
    <script>
      var base_url = '../../../..';
      var is_top_frame = false;
        
        var pageToc = [
          {title: "Clustering", url: "#_top", children: [
              {title: "Intro to Clustering", url: "#intro-to-clustering" },
              {title: "K-Means Clustering", url: "#k-means-clustering" },
              {title: "More On K-Means (Evaluate Accuracy)", url: "#more-on-k-means-evaluate-accuracy" },
              {title: "Lab", url: "#lab" },
          ]},
        ];

    </script>
    <script src="../../../../js/base.js"></script>
      <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
      <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script> 
</head>

<body>
<script>
if (is_top_frame) { $('body').addClass('wm-top-page'); }
</script>



<div class="container-fluid wm-page-content">
  <a name="_top"></a>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../../../Martinos/cluster/cluster/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../../../Martinos/cluster/cluster/" class="btn btn-xs btn-link">
        Cluster
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href="../Multiclass_Prediction/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../Multiclass_Prediction/" class="btn btn-xs btn-link">
        7. Multiclass Prediction
      </a>
    </div>
    
  </div>

    

    <h1 id="clustering">Clustering</h1>
<h2 id="intro-to-clustering">Intro to Clustering</h2>
<p>Customer segmentation is the practice of partitioning a customer base into groups of individuals that have similar characteristics. It is a significant strategy, as it allows the business to target specific groups of customers, so as to more effectively allocate marketing resources. For example, one group might contain customers who are high profit and low risk. That is, more likely to purchase products or subscribe for a service. Knowing this information allows a business to devote more time and attention to retaining these customers. Another group might include customers from nonprofit organizations and so on. </p>
<p><img alt="clustering_1.jpg" src="../Images/clustering/clustering_1.jpg" /></p>
<p>Clustering means finding clusters in a dataset, unsupervised. So what is a cluster? A cluster is a group of data points or objects in a dataset that are similar to other objects in the group, and dissimilar to datapoints in other clusters. Now the question is," What is different between clustering and classification?"</p>
<p><img alt="clustering_2.jpg" src="../Images/clustering/clustering_2.jpg" /></p>
<p>Let's look at our customer dataset again. Classification algorithms predict categorical classed labels. This means assigning instances to predefined classes such as defaulted or not defaulted. For example, if an analyst wants to analyze customer data in order to know which customers might default on their payments, she uses a labeled dataset as training data and uses classification approaches such as a decision tree, Support Vector Machines or SVM, or logistic regression, to predict the default value for a new or unknown customer. Generally speaking, classification is a supervised learning where each training data instance belongs to a particular class. In clustering however, the data is unlabeled and the process is unsupervised. For example, we can use a clustering algorithm such as k-means to group similar customers as mentioned, and assign them to a cluster, based on whether they share similar attributes, such as; age, education, and so on.</p>
<p><img alt="clustering_3.jpg" src="../Images/clustering/clustering_3.jpg" /></p>
<p>In the insurance industry, clustering is used for fraud detection in claims analysis, or to evaluate the insurance risk of certain customers based on their segments. In publication media, clustering is used to auto categorize news based on his content or to tag news, then cluster it so as to recommend similar news articles to readers. In medicine, it can be used to characterize patient behavior, based on their similar characteristics. So as to identify successful medical therapies for different illnesses or in biology, clustering is used to group genes with similar expression patterns or to cluster genetic markers to identify family ties.</p>
<p><img alt="clustering_4.jpg" src="../Images/clustering/clustering_4.jpg" /></p>
<p><img alt="clustering_5.jpg" src="../Images/clustering/clustering_5.jpg" /></p>
<h2 id="k-means-clustering">K-Means Clustering</h2>
<p><img alt="clustering_6.jpg" src="../Images/clustering/clustering_6.jpg" />
Customer segmentation is the practice of partitioning a customer base into groups of individuals that have similar characteristics. One of the algorithms that can be used for customer segmentation is K-Means clustering. K-Means can group data only unsupervised based on the similarity of customers to each other. </p>
<p><img alt="clustering_7.jpg" src="../Images/clustering/clustering_7.jpg" /></p>
<p>There are various types of clustering algorithms such as:</p>
<ul>
<li>Partitioning, hierarchical or density-based clustering.</li>
<li>K-Means is a type of partitioning clustering, that is, it divides the data into K <strong>non-overlapping</strong> subsets or clusters without any cluster internal structure or labels. This means, it's an unsupervised algorithm. </li>
<li>Objects within a cluster are very similar</li>
<li>Objects across different clusters are very different or dissimilar. As you can see, for using K-Means we have to find similar samples: for example, similar customers.</li>
</ul>
<p>Now, we face a couple of key questions. First, how can we find the similarity of samples in clustering, and then how do we measure how similar two customers are with regard to their demographics?</p>
<p><img alt="clustering_8.jpg" src="../Images/clustering/clustering_8.jpg" /></p>
<p>Though the objective of K-Means is to form clusters in such a way that similar samples go into a cluster, and dissimilar samples fall into different clusters, it can be shown that instead of a similarity metric, we can use dissimilarity metrics. In other words, conventionally the distance of samples from each other is used to shape the clusters. So we can say K-Means tries to minimize the intra-cluster distances and maximize the inter-cluster distances. Now, the question is, how can we calculate the dissimilarity or distance of two cases such as two customers?</p>
<p>Assume that we have two customers, we will call them Customer one and two. Let's also assume that we have only one feature for each of these two customers and that feature is age. We can easily use a specific type of Minkowski distance to calculate the distance of these two customers. Indeed, it is the Euclidean distance. 
<img alt="clustering_9.jpg" src="../Images/clustering/clustering_9.jpg" /></p>
<p>What about if we have more than one feature, for example, age and income?</p>
<p>For example, if we have income and age for each customer, we can still use the same formula but this time in a two-dimensional space.</p>
<p><img alt="clustering_10.jpg" src="../Images/clustering/clustering_10.jpg" /></p>
<p>Also, we can use the same distance matrix for multidimensional vectors. Of course, we have to normalize our feature set to get the accurate dissimilarity measure. There are other dissimilarity measures as well that can be used for this purpose, but it is highly dependent on datatype and also the domain that clustering is done for it. For example you may use Euclidean distance, cosine similarity, average distance, and so on. Indeed, the similarity measure highly controls how the clusters are formed, so it is recommended to understand the domain knowledge of your dataset and datatype of features and then choose the meaningful distance measurement.</p>
<p><img alt="clustering_11.jpg" src="../Images/clustering/clustering_11.jpg" /></p>
<p>Now, let's see how K-Means clustering works. For the sake of simplicity, let's assume that our dataset has only two features: the age and income of customers. This means, it's a two-dimensional space. We can show the distribution of customers using a scatter plot: </p>
<p><img alt="clustering_12.jpg" src="../Images/clustering/clustering_12.jpg" /></p>
<p>The Y-axis indicates age and the X-axis shows income of customers. We try to cluster the customer dataset into distinct groups or clusters based on these two dimensions. </p>
<p>In the first step, we should determine the number of clusters. The key concept of the K-Means algorithm is that it randomly picks a center point for each cluster. It means we must initialize K which represents number of clusters. Essentially, determining the number of clusters in a dataset or K is a hard problem in K-Means, that we will discuss later. </p>
<p>For now, let's put K equals three here for our sample dataset. It is like we have three representative points for our clusters. </p>
<p><img alt="clustering_13.jpg" src="../Images/clustering/clustering_13.jpg" /></p>
<p>These three data points are called centroids of clusters and should be of same feature size of our customer feature set. There are two approaches to choose these centroids. One, we can randomly choose three observations out of the dataset and use these observations as the initial means. </p>
<p><img alt="clustering_14.jpg" src="../Images/clustering/clustering_14.jpg" /></p>
<p>Or two, we can create three random points as centroids of the clusters which is our choice that is shown in the plot with red color.</p>
<p><img alt="clustering_15.jpg" src="../Images/clustering/clustering_15.jpg" /></p>
<p>After the initialization step which was defining the centroid of each cluster, we have to assign each customer to the closest center. For this purpose, we have to calculate the distance of each data point or in our case each customer from the centroid points. As mentioned before, depending on the nature of the data and the purpose for which clustering is being used, different measures of distance may be used to place items into clusters. Therefore, you will form a matrix where each row represents the distance of a customer from each centroid. </p>
<p><img alt="clustering_16.jpg" src="../Images/clustering/clustering_16.jpg" /></p>
<p>It is called the Distance Matrix. The main objective of K-Means clustering is to minimize the distance of data points from the centroid of this cluster and maximize the distance from other cluster centroids. </p>
<p><img alt="clustering_17.jpg" src="../Images/clustering/clustering_17.jpg" /></p>
<p>So, in this step, we have to find the closest centroid to each data point. We can use the distance matrix to find the nearest centroid to datapoints. <strong>Finding the closest centroids for each data point, we assign each data point to that cluster</strong>. In other words, all the customers will fall to a cluster based on their distance from centroids. We can easily say that it does not result in good clusters because the centroids were chosen randomly from the first. Indeed, the model would have a high error. Here, error is the total distance of each point from its centroid. It can be shown as within-cluster sum of squares error.</p>
<p><img alt="clustering_18.jpg" src="../Images/clustering/clustering_18.jpg" /></p>
<blockquote>
<p>In case that was confusing, every dot is closest to one of the clusters mathematically. So assign every dot the category of the cluster center it is closest to. Redundant but hopefully helps.</p>
</blockquote>
<p>Intuitively, we try to reduce this error. It means we should shape clusters in such a way that the total distance of all members of a cluster from its centroid be minimized. </p>
<p>Now, the question is, how can we turn it into better clusters with less error?</p>
<p><img alt="clustering_19.jpg" src="../Images/clustering/clustering_19.jpg" /></p>
<p>Okay, we move centroids. In the next step, each cluster center will be updated to be the mean for datapoints in its cluster.</p>
<p><img alt="clustering_20.jpg" src="../Images/clustering/clustering_20.jpg" /></p>
<p>Indeed, each centroid moves according to their cluster members. In other words the centroid of each of the three clusters becomes the new mean. For example, if point A coordination is 7.4 and 3.6, and B point features are 7.8 and 3.8, the new centroid of this cluster with two points would be the average of them, which is 7.6 and 3.7. Now, we have new centroids. As you can guess, once again we will have to calculate the distance of all points from the new centroids. The points are reclustered and the centroids move again. This continues until the centroids no longer move. Please note that whenever a centroid moves, each point's distance to the centroid needs to be measured again.</p>
<p><img alt="clustering_21.jpg" src="../Images/clustering/clustering_21.jpg" /></p>
<p>Yes, K-Means is an iterative algorithm and we have to repeat steps two to four until the algorithm converges.</p>
<p><img alt="clustering_22.jpg" src="../Images/clustering/clustering_22.jpg" />
<img alt="clustering_23.jpg" src="../Images/clustering/clustering_23.jpg" />
<img alt="clustering_24.jpg" src="../Images/clustering/clustering_24.jpg" /></p>
<p>In each iteration, it will move the centroids, calculate the distances from new centroids and assign data points to the nearest centroid. It results in the clusters with minimum error or the most dense clusters. However, as it is a heuristic algorithm, there is no guarantee that it will converge to the global optimum and the result may depend on the initial clusters. It means, this algorithm is guaranteed to converge to a result, but the result may be a local optimum i.e. not necessarily the best possible outcome. To solve this problem, it is common to run the whole process multiple times with different starting conditions. This means with randomized starting centroids, it may give a better outcome. As the algorithm is usually very fast, it wouldn't be any problem to run it multiple times. Thanks for watching this video.</p>
<h2 id="more-on-k-means-evaluate-accuracy">More On K-Means (Evaluate Accuracy)</h2>
<p>Euclidean distance is used to measure the distance from the object to the centroid. Please note, however, that you can also use different types of distance measurements, not just Euclidean distance. Euclidean distance is used because it's the most popular.</p>
<p>Now, the questions is, how can we evaluate the goodness of the clusters formed by k-Means? In other words, how do we calculate the accuracy of k-Means clustering? One way is to compare the clusters with the ground truth, if it's available. However, because k-Means is an unsupervised algorithm we usually don't have ground truth in real world problems to be used. </p>
<p>But there is still a way to say how bad each cluster is, based on the objective of the k-Means. This value is the average distance between data points within a cluster.</p>
<p>Also, average of the distances of data points from their cluster centroids can be used as a metric of error for the clustering algorithm. </p>
<p>Essentially, determining the number of clusters in a data set, or k as in the k-Means algorithm, is a frequent problem in data clustering. The correct choice of K is often ambiguous because it's very dependent on the shape and scale of the distribution of points in a dataset. There are some approaches to address this problem, but one of the techniques that is commonly used is to run the clustering across the different values of K and looking at a metric of accuracy for clustering.</p>
<p><img alt="clustering_25.jpg" src="../Images/clustering/clustering_25.jpg" /></p>
<p>This metric can be mean, distance between data points and their cluster's centroid, which indicate how dense our clusters are or, to what extent we minimize the error of clustering. Then, looking at the change of this metric, we can find the best value for K.
Play video starting at :2:49 and follow transcript2:49
But the problem is that with increasing the number of clusters, the distance of centroids to data points will always reduce. This means increasing K will always decrease the error. So, the value of the metric as a function of K is plotted and the elbow point is determined where the rate of decrease sharply shifts. It is the right K for clustering. This method is called the elbow method.</p>
<p>So let's recap k-Means clustering: k-Means is a partition-based clustering which is A, relatively efficient on medium and large sized data sets; B, produces sphere-like clusters because the clusters are shaped around the centroids; and C, its drawback is that we should pre-specify the number of clusters, and this is not an easy task. Thanks for watching. </p>
<h2 id="lab">Lab</h2>
<h3 id="generated-data-blobs">Generated Data (Blobs)</h3>
<pre><code class="language-bash"># Setup Environment
cd ~/Desktop; rm -r temp; # To remove
cd ~/Desktop; mkdir temp; cd temp; pyenv activate venv3.10.4;
# Data
path='https://cf-courses-data.s3.us.cloud-object-storage.appdomain.cloud/IBMDeveloperSkillsNetwork-ML0101EN-SkillsNetwork/labs/Module%204/data/Cust_Segmentation.csv'
wget $path
</code></pre>
<pre><code class="language-python">import random 
import numpy as np 
import matplotlib.pyplot as plt 
import pandas as pd
from sklearn.cluster import KMeans 
from sklearn.datasets import make_blobs 
from sklearn.preprocessing import StandardScaler
import matplotlib.pyplot as plt
np.random.seed(0)

# Data
path='https://cf-courses-data.s3.us.cloud-object-storage.appdomain.cloud/IBMDeveloperSkillsNetwork-ML0101EN-SkillsNetwork/labs/Module%204/data/Cust_Segmentation.csv'

</code></pre>
<p>Next we will be making random clusters of points by using the <strong>make_blobs</strong> class. The <strong>make_blobs</strong> class can take in many inputs, but we will be using these specific ones.</p>
<p>Input:<br />
<em> n_samples: 5000 - total num of points equally divided among clusters.<br />
</em> center: [[4,4],[-2,-1],[2,-3],[1,1]] num of centers to generate, or the fixed center locations.<br />
* cluster_std: 0.9 the standard deviation of the clusters.  </p>
<p>Output:
* X: Array of shape [n_samples, n_features]. (Feature Matrix) - generated samples.<br />
* y: Arayy of shape [n_samples] (Response Vector) - the integer labels for cluster membership of each sample.</p>
<pre><code class="language-python">X, y = make_blobs(n_samples=5000, centers=[[4,4], [-2, -1], [2, -3], [1, 1]], cluster_std=0.9)
# plot
plt.scatter(X[:, 0], X[:, 1], marker='.')
plt.show()
</code></pre>
<p>The KMeans class has many parameters that can be used, but we will be using these three:</p>
<ul>
<li><strong>init</strong>: Initialization method of the centroids.</li>
<li>Value will be: "k-means++"</li>
<li>k-means++: Selects initial cluster centers for k-mean clustering in a smart way to speed up convergence.</li>
<li><strong>n_clusters</strong>: The number of clusters to form as well as the number of centroids to generate.</li>
<li>Value will be: 4 (since we have 4 centers)</li>
<li><strong>n_init</strong>: Number of time the k-means algorithm will be run with different centroid seeds. The final results will be the best output of n_init consecutive runs in terms of inertia.</li>
<li>Value will be: 12 </li>
</ul>
<pre><code class="language-python">k_means = KMeans(init = &quot;k-means++&quot;, n_clusters = 4, n_init = 12)
# fit
k_means.fit(X)
</code></pre>
<p>Now let's grab the labels for each point in the model using KMeans' <strong>.labels_</strong> attribute and save it as <strong>k_means_labels</strong>.</p>
<pre><code class="language-python">k_means_labels = k_means.labels_
k_means_labels # 5000 points labeled
</code></pre>
<p>We will also get the coordinates of the cluster centers using KMeans' <strong>.cluster_centers_</strong> and save it as <strong>k_means_cluster_centers</strong>.</p>
<pre><code class="language-python">k_means_cluster_centers = k_means.cluster_centers_
k_means_cluster_centers
</code></pre>
<pre><code class="language-python"># Creating the visual plot
def plot():
    # Initialize the plot with the specified dimensions.
    fig = plt.figure(figsize=(6, 4))
    # Colors uses a color map, which will produce an array of colors based on
    # the number of labels there are. We use set(k_means_labels) to get the
    # unique labels.
    colors = plt.cm.Spectral(np.linspace(0, 1, len(set(k_means_labels))))
    # Create a plot
    ax = fig.add_subplot(1, 1, 1)
    # For loop that plots the data points and centroids.
    # k will range from 0-3, which will match the possible clusters that each
    # data point is in.
    for k, col in zip(range(len([[4,4], [-2, -1], [2, -3], [1, 1]])), colors):
        # Create a list of all data points, where the data points that are 
        # in the cluster (ex. cluster 0) are labeled as true, else they are
        # labeled as false.
        my_members = (k_means_labels == k)
        # Define the centroid, or cluster center.
        cluster_center = k_means_cluster_centers[k]
        # Plots the datapoints with color col.
        ax.plot(X[my_members, 0], X[my_members, 1], 'w', markerfacecolor=col, marker='.')
        # Plots the centroids with specified color, but with a darker outline
        ax.plot(cluster_center[0], cluster_center[1], 'o', markerfacecolor=col,  markeredgecolor='k', markersize=6)
    # Title of the plot
    ax.set_title('KMeans')
    # Remove x-axis ticks
    ax.set_xticks(())
    # Remove y-axis ticks
    ax.set_yticks(())
    # Show the plot
    plt.show()

plot()
</code></pre>
<h3 id="customer-segmentation">Customer Segmentation</h3>
<p>Imagine that you have a customer dataset, and you need to apply customer segmentation on this historical data.
Customer segmentationÂ is the practice of partitioning a customer base into groups of individuals that have similar characteristics. It is a significant strategy as a business can target these specific groups of customers and effectively allocate marketing resources. For example, one group might contain customers who are high-profit and low-risk, that is, more likely to purchase products, or subscribe for a service. A business task is to retain those customers. Another group might include customers from non-profit organizations and so on.</p>
<pre><code class="language-python">cust_df = pd.read_csv(&quot;Cust_Segmentation.csv&quot;)
cust_df.head()
# Pre-processing (address is categorical; not applicable for k-means)
df = cust_df.drop('Address', axis=1)
df.head()
# Normalizing over standard deviation
## Normalization is a statistical method that helps mathematical-based algorithms to interpret features with different magnitudes and distributions equally. We use StandardScaler() to normalize our dataset.
X = df.values[:,1:] # age and onwards...don't use CustomerId; not a feature
X = np.nan_to_num(X)
Clus_dataSet = StandardScaler().fit_transform(X)
Clus_dataSet
# Modeling
clusterNum = 3
k_means = KMeans(init = &quot;k-means++&quot;, n_clusters = clusterNum, n_init = 12)
k_means.fit(X)
labels = k_means.labels_
print(labels)
# Insights (We assign the labels to each row in the dataframe.)
df[&quot;Clus_km&quot;] = labels
df.head(5)
# Check centroids by averaging the features in each cluster
## Note Customer ID meaningless here...
df.groupby('Clus_km').mean()
# Look at distribution of customers based on their age and income:
area = np.pi * ( X[:, 1])**2  
plt.scatter(X[:, 0], X[:, 3], s=area, c=labels.astype(float), alpha=0.5)
plt.xlabel('Age', fontsize=18)
plt.ylabel('Income', fontsize=16)
plt.show()

# What is this?
from mpl_toolkits.mplot3d import Axes3D 
fig = plt.figure(1, figsize=(8, 6))
plt.clf()
ax = Axes3D(fig, rect=[0, 0, .95, 1], elev=48, azim=134)

plt.cla()
# plt.ylabel('Age', fontsize=18)
# plt.xlabel('Income', fontsize=16)
# plt.zlabel('Education', fontsize=16)
ax.set_xlabel('Education')
ax.set_ylabel('Age')
ax.set_zlabel('Income')

ax.scatter(X[:, 1], X[:, 0], X[:, 3], c= labels.astype(float))
plt.show()
</code></pre>
<p>k-means will partition your customers into mutually exclusive groups, for example, into 3 clusters. The customers in each cluster are similar to each other demographically.
Now we can create a profile for each group, considering the common characteristics of each cluster.
For example, the 3 clusters can be:</p>
<ul>
<li>AFFLUENT, EDUCATED AND OLD AGED</li>
<li>MIDDLE AGED AND MIDDLE INCOME</li>
<li>YOUNG AND LOW INCOME</li>
</ul>

  <br>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../../../Martinos/cluster/cluster/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../../../Martinos/cluster/cluster/" class="btn btn-xs btn-link">
        Cluster
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href="../Multiclass_Prediction/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../Multiclass_Prediction/" class="btn btn-xs btn-link">
        7. Multiclass Prediction
      </a>
    </div>
    
  </div>

    <br>
</div>

<footer class="col-md-12 wm-page-content">
  <p>Documentation built with <a href="http://www.mkdocs.org/">MkDocs</a> using <a href="">Windmill Dark</a> theme by None (noraj).</p>
</footer>

</body>
</html>